(() => {
	var e = {
			124: (e, t, s) => {
				var i = s(325);
				e.exports = function () {
					return i.Date.now();
				};
			},
			128: (e, t, s) => {
				var i = s(800),
					r = /^\s+/;
				e.exports = function (e) {
					return e ? e.slice(0, i(e) + 1).replace(r, "") : e;
				};
			},
			144: function (e) {
				e.exports = (function () {
					"use strict";
					const e = "undefined" != typeof window,
						t =
							(e && !("onscroll" in window)) ||
							("undefined" != typeof navigator &&
								/(gle|ing|ro)bot|crawl|spider/i.test(navigator.userAgent)),
						s = e && window.devicePixelRatio > 1,
						i = {
							elements_selector: ".lazy",
							container: t || e ? document : null,
							threshold: 300,
							thresholds: null,
							data_src: "src",
							data_srcset: "srcset",
							data_sizes: "sizes",
							data_bg: "bg",
							data_bg_hidpi: "bg-hidpi",
							data_bg_multi: "bg-multi",
							data_bg_multi_hidpi: "bg-multi-hidpi",
							data_bg_set: "bg-set",
							data_poster: "poster",
							class_applied: "applied",
							class_loading: "loading",
							class_loaded: "loaded",
							class_error: "error",
							class_entered: "entered",
							class_exited: "exited",
							unobserve_completed: !0,
							unobserve_entered: !1,
							cancel_on_exit: !0,
							callback_enter: null,
							callback_exit: null,
							callback_applied: null,
							callback_loading: null,
							callback_loaded: null,
							callback_error: null,
							callback_finish: null,
							callback_cancel: null,
							use_native: !1,
							restore_on_error: !1,
						},
						r = (e) => Object.assign({}, i, e),
						n = function (e, t) {
							let s;
							const i = "LazyLoad::Initialized",
								r = new e(t);
							try {
								s = new CustomEvent(i, { detail: { instance: r } });
							} catch (e) {
								(s = document.createEvent("CustomEvent")),
									s.initCustomEvent(i, !1, !1, { instance: r });
							}
							window.dispatchEvent(s);
						},
						a = "src",
						o = "srcset",
						l = "sizes",
						c = "poster",
						d = "llOriginalAttrs",
						p = "data",
						u = "loading",
						h = "loaded",
						m = "applied",
						f = "error",
						g = "native",
						v = "data-",
						b = "ll-status",
						y = (e, t) => e.getAttribute(v + t),
						w = (e) => y(e, b),
						E = (e, t) =>
							((e, t, s) => {
								const i = v + t;
								null !== s ? e.setAttribute(i, s) : e.removeAttribute(i);
							})(e, b, t),
						S = (e) => E(e, null),
						x = (e) => null === w(e),
						T = (e) => w(e) === g,
						L = [u, h, m, f],
						C = (e, t, s, i) => {
							e &&
								"function" == typeof e &&
								(void 0 === i ? (void 0 === s ? e(t) : e(t, s)) : e(t, s, i));
						},
						O = (t, s) => {
							e && "" !== s && t.classList.add(s);
						},
						A = (t, s) => {
							e && "" !== s && t.classList.remove(s);
						},
						M = (e) => e.llTempImage,
						k = (e, t) => {
							if (!t) return;
							const s = t._observer;
							s && s.unobserve(e);
						},
						_ = (e, t) => {
							e && (e.loadingCount += t);
						},
						P = (e, t) => {
							e && (e.toLoadCount = t);
						},
						z = (e) => {
							let t = [];
							for (let s, i = 0; (s = e.children[i]); i += 1)
								"SOURCE" === s.tagName && t.push(s);
							return t;
						},
						I = (e, t) => {
							const s = e.parentNode;
							s && "PICTURE" === s.tagName && z(s).forEach(t);
						},
						D = (e, t) => {
							z(e).forEach(t);
						},
						$ = [a],
						B = [a, c],
						W = [a, o, l],
						N = [p],
						q = (e) => !!e[d],
						H = (e) => e[d],
						V = (e) => delete e[d],
						G = (e, t) => {
							if (q(e)) return;
							const s = {};
							t.forEach((t) => {
								s[t] = e.getAttribute(t);
							}),
								(e[d] = s);
						},
						F = (e, t) => {
							if (!q(e)) return;
							const s = H(e);
							t.forEach((t) => {
								((e, t, s) => {
									s ? e.setAttribute(t, s) : e.removeAttribute(t);
								})(e, t, s[t]);
							});
						},
						R = (e, t, s) => {
							O(e, t.class_applied),
								E(e, m),
								s &&
									(t.unobserve_completed && k(e, t),
									C(t.callback_applied, e, s));
						},
						j = (e, t, s) => {
							O(e, t.class_loading),
								E(e, u),
								s && (_(s, 1), C(t.callback_loading, e, s));
						},
						Y = (e, t, s) => {
							s && e.setAttribute(t, s);
						},
						X = (e, t) => {
							Y(e, l, y(e, t.data_sizes)),
								Y(e, o, y(e, t.data_srcset)),
								Y(e, a, y(e, t.data_src));
						},
						U = {
							IMG: (e, t) => {
								I(e, (e) => {
									G(e, W), X(e, t);
								}),
									G(e, W),
									X(e, t);
							},
							IFRAME: (e, t) => {
								G(e, $), Y(e, a, y(e, t.data_src));
							},
							VIDEO: (e, t) => {
								D(e, (e) => {
									G(e, $), Y(e, a, y(e, t.data_src));
								}),
									G(e, B),
									Y(e, c, y(e, t.data_poster)),
									Y(e, a, y(e, t.data_src)),
									e.load();
							},
							OBJECT: (e, t) => {
								G(e, N), Y(e, p, y(e, t.data_src));
							},
						},
						K = ["IMG", "IFRAME", "VIDEO", "OBJECT"],
						Z = (e, t) => {
							!t ||
								((e) => e.loadingCount > 0)(t) ||
								((e) => e.toLoadCount > 0)(t) ||
								C(e.callback_finish, t);
						},
						Q = (e, t, s) => {
							e.addEventListener(t, s), (e.llEvLisnrs[t] = s);
						},
						J = (e, t, s) => {
							e.removeEventListener(t, s);
						},
						ee = (e) => !!e.llEvLisnrs,
						te = (e) => {
							if (!ee(e)) return;
							const t = e.llEvLisnrs;
							for (let s in t) {
								const i = t[s];
								J(e, s, i);
							}
							delete e.llEvLisnrs;
						},
						se = (e, t, s) => {
							((e) => {
								delete e.llTempImage;
							})(e),
								_(s, -1),
								((e) => {
									e && (e.toLoadCount -= 1);
								})(s),
								A(e, t.class_loading),
								t.unobserve_completed && k(e, s);
						},
						ie = (e, t, s) => {
							const i = M(e) || e;
							ee(i) ||
								((e, t, s) => {
									ee(e) || (e.llEvLisnrs = {});
									const i = "VIDEO" === e.tagName ? "loadeddata" : "load";
									Q(e, i, t), Q(e, "error", s);
								})(
									i,
									(r) => {
										((e, t, s, i) => {
											const r = T(t);
											se(t, s, i),
												O(t, s.class_loaded),
												E(t, h),
												C(s.callback_loaded, t, i),
												r || Z(s, i);
										})(0, e, t, s),
											te(i);
									},
									(r) => {
										((e, t, s, i) => {
											const r = T(t);
											se(t, s, i),
												O(t, s.class_error),
												E(t, f),
												C(s.callback_error, t, i),
												s.restore_on_error && F(t, W),
												r || Z(s, i);
										})(0, e, t, s),
											te(i);
									},
								);
						},
						re = (e, t, i) => {
							((e) => K.indexOf(e.tagName) > -1)(e)
								? ((e, t, s) => {
										ie(e, t, s),
											((e, t, s) => {
												const i = U[e.tagName];
												i && (i(e, t), j(e, t, s));
											})(e, t, s);
								  })(e, t, i)
								: ((e, t, i) => {
										((e) => {
											e.llTempImage = document.createElement("IMG");
										})(e),
											ie(e, t, i),
											((e) => {
												q(e) ||
													(e[d] = { backgroundImage: e.style.backgroundImage });
											})(e),
											((e, t, i) => {
												const r = y(e, t.data_bg),
													n = y(e, t.data_bg_hidpi),
													o = s && n ? n : r;
												o &&
													((e.style.backgroundImage = `url("${o}")`),
													M(e).setAttribute(a, o),
													j(e, t, i));
											})(e, t, i),
											((e, t, i) => {
												const r = y(e, t.data_bg_multi),
													n = y(e, t.data_bg_multi_hidpi),
													a = s && n ? n : r;
												a && ((e.style.backgroundImage = a), R(e, t, i));
											})(e, t, i),
											((e, t, s) => {
												const i = y(e, t.data_bg_set);
												if (!i) return;
												let r = i.split("|").map((e) => `image-set(${e})`);
												(e.style.backgroundImage = r.join()), R(e, t, s);
											})(e, t, i);
								  })(e, t, i);
						},
						ne = (e) => {
							e.removeAttribute(a), e.removeAttribute(o), e.removeAttribute(l);
						},
						ae = (e) => {
							I(e, (e) => {
								F(e, W);
							}),
								F(e, W);
						},
						oe = {
							IMG: ae,
							IFRAME: (e) => {
								F(e, $);
							},
							VIDEO: (e) => {
								D(e, (e) => {
									F(e, $);
								}),
									F(e, B),
									e.load();
							},
							OBJECT: (e) => {
								F(e, N);
							},
						},
						le = (e, t) => {
							((e) => {
								const t = oe[e.tagName];
								t
									? t(e)
									: ((e) => {
											if (!q(e)) return;
											const t = H(e);
											e.style.backgroundImage = t.backgroundImage;
									  })(e);
							})(e),
								((e, t) => {
									x(e) ||
										T(e) ||
										(A(e, t.class_entered),
										A(e, t.class_exited),
										A(e, t.class_applied),
										A(e, t.class_loading),
										A(e, t.class_loaded),
										A(e, t.class_error));
								})(e, t),
								S(e),
								V(e);
						},
						ce = ["IMG", "IFRAME", "VIDEO"],
						de = (e) => e.use_native && "loading" in HTMLImageElement.prototype,
						pe = (e, t, s) => {
							e.forEach((e) =>
								((e) => e.isIntersecting || e.intersectionRatio > 0)(e)
									? ((e, t, s, i) => {
											const r = ((e) => L.indexOf(w(e)) >= 0)(e);
											E(e, "entered"),
												O(e, s.class_entered),
												A(e, s.class_exited),
												((e, t, s) => {
													t.unobserve_entered && k(e, s);
												})(e, s, i),
												C(s.callback_enter, e, t, i),
												r || re(e, s, i);
									  })(e.target, e, t, s)
									: ((e, t, s, i) => {
											x(e) ||
												(O(e, s.class_exited),
												((e, t, s, i) => {
													s.cancel_on_exit &&
														((e) => w(e) === u)(e) &&
														"IMG" === e.tagName &&
														(te(e),
														((e) => {
															I(e, (e) => {
																ne(e);
															}),
																ne(e);
														})(e),
														ae(e),
														A(e, s.class_loading),
														_(i, -1),
														S(e),
														C(s.callback_cancel, e, t, i));
												})(e, t, s, i),
												C(s.callback_exit, e, t, i));
									  })(e.target, e, t, s),
							);
						},
						ue = (e) => Array.prototype.slice.call(e),
						he = (e) => e.container.querySelectorAll(e.elements_selector),
						me = (e) => ((e) => w(e) === f)(e),
						fe = (e, t) => ((e) => ue(e).filter(x))(e || he(t)),
						ge = function (t, s) {
							const i = r(t);
							(this._settings = i),
								(this.loadingCount = 0),
								((e, t) => {
									de(e) ||
										(t._observer = new IntersectionObserver((s) => {
											pe(s, e, t);
										}, ((e) => ({ root: e.container === document ? null : e.container, rootMargin: e.thresholds || e.threshold + "px" }))(e)));
								})(i, this),
								((t, s) => {
									e &&
										((s._onlineHandler = () => {
											((e, t) => {
												var s;
												((s = he(e)), ue(s).filter(me)).forEach((t) => {
													A(t, e.class_error), S(t);
												}),
													t.update();
											})(t, s);
										}),
										window.addEventListener("online", s._onlineHandler));
								})(i, this),
								this.update(s);
						};
					return (
						(ge.prototype = {
							update: function (e) {
								const s = this._settings,
									i = fe(e, s);
								var r, n;
								P(this, i.length),
									t
										? this.loadAll(i)
										: de(s)
										? ((e, t, s) => {
												e.forEach((e) => {
													-1 !== ce.indexOf(e.tagName) &&
														((e, t, s) => {
															e.setAttribute("loading", "lazy"),
																ie(e, t, s),
																((e, t) => {
																	const s = U[e.tagName];
																	s && s(e, t);
																})(e, t),
																E(e, g);
														})(e, t, s);
												}),
													P(s, 0);
										  })(i, s, this)
										: ((n = i),
										  ((e) => {
												e.disconnect();
										  })((r = this._observer)),
										  ((e, t) => {
												t.forEach((t) => {
													e.observe(t);
												});
										  })(r, n));
							},
							destroy: function () {
								this._observer && this._observer.disconnect(),
									e &&
										window.removeEventListener("online", this._onlineHandler),
									he(this._settings).forEach((e) => {
										V(e);
									}),
									delete this._observer,
									delete this._settings,
									delete this._onlineHandler,
									delete this.loadingCount,
									delete this.toLoadCount;
							},
							loadAll: function (e) {
								const t = this._settings;
								fe(e, t).forEach((e) => {
									k(e, this), re(e, t, this);
								});
							},
							restoreAll: function () {
								const e = this._settings;
								he(e).forEach((t) => {
									le(t, e);
								});
							},
						}),
						(ge.load = (e, t) => {
							const s = r(t);
							re(e, s);
						}),
						(ge.resetStatus = (e) => {
							S(e);
						}),
						e &&
							((e, t) => {
								if (t)
									if (t.length) for (let s, i = 0; (s = t[i]); i += 1) n(e, s);
									else n(e, t);
							})(ge, window.lazyLoadOptions),
						ge
					);
				})();
			},
			221: (e, t, s) => {
				var i = s(805),
					r = s(124),
					n = s(374),
					a = Math.max,
					o = Math.min;
				e.exports = function (e, t, s) {
					var l,
						c,
						d,
						p,
						u,
						h,
						m = 0,
						f = !1,
						g = !1,
						v = !0;
					if ("function" != typeof e)
						throw new TypeError("Expected a function");
					function b(t) {
						var s = l,
							i = c;
						return (l = c = void 0), (m = t), (p = e.apply(i, s));
					}
					function y(e) {
						var s = e - h;
						return void 0 === h || s >= t || s < 0 || (g && e - m >= d);
					}
					function w() {
						var e = r();
						if (y(e)) return E(e);
						u = setTimeout(
							w,
							(function (e) {
								var s = t - (e - h);
								return g ? o(s, d - (e - m)) : s;
							})(e),
						);
					}
					function E(e) {
						return (u = void 0), v && l ? b(e) : ((l = c = void 0), p);
					}
					function S() {
						var e = r(),
							s = y(e);
						if (((l = arguments), (c = this), (h = e), s)) {
							if (void 0 === u)
								return (function (e) {
									return (m = e), (u = setTimeout(w, t)), f ? b(e) : p;
								})(h);
							if (g) return clearTimeout(u), (u = setTimeout(w, t)), b(h);
						}
						return void 0 === u && (u = setTimeout(w, t)), p;
					}
					return (
						(t = n(t) || 0),
						i(s) &&
							((f = !!s.leading),
							(d = (g = "maxWait" in s) ? a(n(s.maxWait) || 0, t) : d),
							(v = "trailing" in s ? !!s.trailing : v)),
						(S.cancel = function () {
							void 0 !== u && clearTimeout(u),
								(m = 0),
								(l = h = c = u = void 0);
						}),
						(S.flush = function () {
							return void 0 === u ? p : E(r());
						}),
						S
					);
				};
			},
			325: (e, t, s) => {
				var i = s(840),
					r = "object" == typeof self && self && self.Object === Object && self,
					n = i || r || Function("return this")();
				e.exports = n;
			},
			346: (e) => {
				e.exports = function (e) {
					return null != e && "object" == typeof e;
				};
			},
			350: (e) => {
				var t = Object.prototype.toString;
				e.exports = function (e) {
					return t.call(e);
				};
			},
			374: (e, t, s) => {
				var i = s(128),
					r = s(805),
					n = s(394),
					a = /^[-+]0x[0-9a-f]+$/i,
					o = /^0b[01]+$/i,
					l = /^0o[0-7]+$/i,
					c = parseInt;
				e.exports = function (e) {
					if ("number" == typeof e) return e;
					if (n(e)) return NaN;
					if (r(e)) {
						var t = "function" == typeof e.valueOf ? e.valueOf() : e;
						e = r(t) ? t + "" : t;
					}
					if ("string" != typeof e) return 0 === e ? e : +e;
					e = i(e);
					var s = o.test(e);
					return s || l.test(e)
						? c(e.slice(2), s ? 2 : 8)
						: a.test(e)
						? NaN
						: +e;
				};
			},
			394: (e, t, s) => {
				var i = s(552),
					r = s(346);
				e.exports = function (e) {
					return "symbol" == typeof e || (r(e) && "[object Symbol]" == i(e));
				};
			},
			552: (e, t, s) => {
				var i = s(873),
					r = s(659),
					n = s(350),
					a = i ? i.toStringTag : void 0;
				e.exports = function (e) {
					return null == e
						? void 0 === e
							? "[object Undefined]"
							: "[object Null]"
						: a && a in Object(e)
						? r(e)
						: n(e);
				};
			},
			659: (e, t, s) => {
				var i = s(873),
					r = Object.prototype,
					n = r.hasOwnProperty,
					a = r.toString,
					o = i ? i.toStringTag : void 0;
				e.exports = function (e) {
					var t = n.call(e, o),
						s = e[o];
					try {
						e[o] = void 0;
						var i = !0;
					} catch (e) {}
					var r = a.call(e);
					return i && (t ? (e[o] = s) : delete e[o]), r;
				};
			},
			800: (e) => {
				var t = /\s/;
				e.exports = function (e) {
					for (var s = e.length; s-- && t.test(e.charAt(s)); );
					return s;
				};
			},
			805: (e) => {
				e.exports = function (e) {
					var t = typeof e;
					return null != e && ("object" == t || "function" == t);
				};
			},
			840: (e, t, s) => {
				var i = "object" == typeof s.g && s.g && s.g.Object === Object && s.g;
				e.exports = i;
			},
			873: (e, t, s) => {
				var i = s(325).Symbol;
				e.exports = i;
			},
			969: (e, t, s) => {
				var i = s(221),
					r = s(805);
				e.exports = function (e, t, s) {
					var n = !0,
						a = !0;
					if ("function" != typeof e)
						throw new TypeError("Expected a function");
					return (
						r(s) &&
							((n = "leading" in s ? !!s.leading : n),
							(a = "trailing" in s ? !!s.trailing : a)),
						i(e, t, { leading: n, maxWait: t, trailing: a })
					);
				};
			},
		},
		t = {};
	function s(i) {
		var r = t[i];
		if (void 0 !== r) return r.exports;
		var n = (t[i] = { exports: {} });
		return e[i].call(n.exports, n, n.exports, s), n.exports;
	}
	(s.g = (function () {
		if ("object" == typeof globalThis) return globalThis;
		try {
			return this || new Function("return this")();
		} catch (e) {
			if ("object" == typeof window) return window;
		}
	})()),
		(() => {
			"use strict";
			const e = {};
			let t = {
				Android: function () {
					return navigator.userAgent.match(/Android/i);
				},
				BlackBerry: function () {
					return navigator.userAgent.match(/BlackBerry/i);
				},
				iOS: function () {
					return navigator.userAgent.match(/iPhone|iPad|iPod/i);
				},
				Opera: function () {
					return navigator.userAgent.match(/Opera Mini/i);
				},
				Windows: function () {
					return navigator.userAgent.match(/IEMobile/i);
				},
				any: function () {
					return (
						t.Android() || t.BlackBerry() || t.iOS() || t.Opera() || t.Windows()
					);
				},
			};
			function i() {
				if (location.hash) return location.hash.replace("#", "");
			}
			let r = (e, t = 500, s = 0) => {
					e.classList.contains("_slide") ||
						(e.classList.add("_slide"),
						(e.style.transitionProperty = "height, margin, padding"),
						(e.style.transitionDuration = t + "ms"),
						(e.style.height = `${e.offsetHeight}px`),
						e.offsetHeight,
						(e.style.overflow = "hidden"),
						(e.style.height = s ? `${s}px` : "0px"),
						(e.style.paddingTop = 0),
						(e.style.paddingBottom = 0),
						(e.style.marginTop = 0),
						(e.style.marginBottom = 0),
						window.setTimeout(() => {
							(e.hidden = !s),
								!s && e.style.removeProperty("height"),
								e.style.removeProperty("padding-top"),
								e.style.removeProperty("padding-bottom"),
								e.style.removeProperty("margin-top"),
								e.style.removeProperty("margin-bottom"),
								!s && e.style.removeProperty("overflow"),
								e.style.removeProperty("transition-duration"),
								e.style.removeProperty("transition-property"),
								e.classList.remove("_slide"),
								document.dispatchEvent(
									new CustomEvent("slideUpDone", { detail: { target: e } }),
								);
						}, t));
				},
				n = (e, t = 500, s = 0) => {
					if (!e.classList.contains("_slide")) {
						e.classList.add("_slide"),
							(e.hidden = !e.hidden && null),
							s && e.style.removeProperty("height");
						let i = e.offsetHeight;
						(e.style.overflow = "hidden"),
							(e.style.height = s ? `${s}px` : "0px"),
							(e.style.paddingTop = 0),
							(e.style.paddingBottom = 0),
							(e.style.marginTop = 0),
							(e.style.marginBottom = 0),
							e.offsetHeight,
							(e.style.transitionProperty = "height, margin, padding"),
							(e.style.transitionDuration = t + "ms"),
							(e.style.height = i + "px"),
							e.style.removeProperty("padding-top"),
							e.style.removeProperty("padding-bottom"),
							e.style.removeProperty("margin-top"),
							e.style.removeProperty("margin-bottom"),
							window.setTimeout(() => {
								e.style.removeProperty("height"),
									e.style.removeProperty("overflow"),
									e.style.removeProperty("transition-duration"),
									e.style.removeProperty("transition-property"),
									e.classList.remove("_slide"),
									document.dispatchEvent(
										new CustomEvent("slideDownDone", { detail: { target: e } }),
									);
							}, t);
					}
				},
				a = !0,
				o = (e = 500) => {
					if (a) {
						const t = document.querySelectorAll("[data-lp]");
						setTimeout(() => {
							t.forEach((e) => {
								e.style.paddingRight = "";
							}),
								(document.body.style.paddingRight = ""),
								document.documentElement.classList.remove("lock");
						}, e),
							(a = !1),
							setTimeout(function () {
								a = !0;
							}, e);
					}
				},
				l = (e = 500) => {
					if (a) {
						const t = document.querySelectorAll("[data-lp]"),
							s = window.innerWidth - document.body.offsetWidth + "px";
						t.forEach((e) => {
							e.style.paddingRight = s;
						}),
							(document.body.style.paddingRight = s),
							document.documentElement.classList.add("lock"),
							(a = !1),
							setTimeout(function () {
								a = !0;
							}, e);
					}
				};
			function c() {
				o(), document.documentElement.classList.remove("menu-open");
			}
			function d(e) {
				setTimeout(() => {
					window.FLS && console.log(e);
				}, 0);
			}
			function p(e) {
				return e.filter(function (e, t, s) {
					return s.indexOf(e) === t;
				});
			}
			function u(e, t) {
				const s = Array.from(e).filter(function (e, s, i) {
					if (e.dataset[t]) return e.dataset[t].split(",")[0];
				});
				if (s.length) {
					const e = [];
					s.forEach((s) => {
						const i = {},
							r = s.dataset[t].split(",");
						(i.value = r[0]),
							(i.type = r[1] ? r[1].trim() : "max"),
							(i.item = s),
							e.push(i);
					});
					let i = e.map(function (e) {
						return (
							"(" +
							e.type +
							"-width: " +
							e.value +
							"px)," +
							e.value +
							"," +
							e.type
						);
					});
					i = p(i);
					const r = [];
					if (i.length)
						return (
							i.forEach((t) => {
								const s = t.split(","),
									i = s[1],
									n = s[2],
									a = window.matchMedia(s[0]),
									o = e.filter(function (e) {
										if (e.value === i && e.type === n) return !0;
									});
								r.push({ itemsArray: o, matchMedia: a });
							}),
							r
						);
				}
			}
			(() => {
				const e = document.querySelectorAll("[data-marquee]"),
					t = "marquee-wrapper",
					s = "marquee-inner",
					i = "marquee-item";
				if (!e.length) return;
				const { head: r } = document;
				const n = (e) => {
						if (!e && !isFunction(e)) return;
						let t = 0;
						const s = () => {
							const s = window.innerWidth;
							t !== s && ((t = s), e());
						};
						window.addEventListener(
							"resize",
							(function (e, t) {
								let s;
								return (...i) => {
									s && clearTimeout(s),
										(s = setTimeout(() => {
											t(...i), (s = null);
										}, e));
								};
							})(50, s),
						),
							s();
					},
					a = (e, t) => (t ? e.offsetHeight : e.offsetWidth);
				e.forEach((e) => {
					if (!e) return;
					((e) => {
						if (!e) return;
						const r = e,
							n = r.children;
						if (!n.length) return;
						r.classList.add(t),
							Array.from(n).forEach((e) => e.classList.add(i));
						const a = `<div class="${s}">${r.innerHTML}</div>`;
						r.innerHTML = a;
					})(e);
					const o = e.firstElementChild;
					let l = [];
					if (!o) return;
					const c = parseFloat(e.getAttribute("data-marquee-space")),
						d = e.querySelectorAll(`.${i}`),
						p = parseFloat(e.getAttribute("data-marquee-speed")) / 10 || 100,
						u = e.hasAttribute("data-marquee-pause-mouse-enter"),
						h = e.getAttribute("data-marquee-direction"),
						m = "bottom" === h || "top" === h,
						f = `marqueeAnimation-${Math.floor(1e7 * Math.random())}`;
					let g = parseFloat(
							window.getComputedStyle(d[0])?.getPropertyValue("margin-right"),
						),
						v = g || (isNaN(c) ? 30 : c),
						b = parseFloat(e.getAttribute("data-marquee-start")) || 0,
						y = 0,
						w = 0,
						E = 0,
						S = o.children.length,
						x = 0,
						T = 0;
					const L = () => {
							(b = 0), o.removeEventListener("animationiteration", L), M();
						},
						C = () => {
							const e = `@keyframes ${f} {\n\t\t\t\t\t 0% {\n\t\t\t\t\t\t transform: translate${
									m ? "Y" : "X"
								}(${b}%);\n\t\t\t\t\t }\n\t\t\t\t\t 100% {\n\t\t\t\t\t\t transform: translate${
									m ? "Y" : "X"
								}(${((e) => {
									switch (h) {
										case "right":
										case "bottom":
											return e;
										default:
											return -e;
									}
								})(w)}px);\n\t\t\t\t\t }\n\t\t\t\t }`,
								t = document.createElement("style");
							t.classList.add(f),
								(t.innerHTML = e),
								r.append(t),
								(o.style.animation = `${f} ${
									(w + (b * w) / 100) / p
								}s infinite linear`);
						},
						O = () => {
							y = w = E = T = x = 0;
							const t = a(e, m);
							let s = Array.from(o.children);
							if (!s.length) return;
							l.length ? (s = [...l]) : (l = s.map((e) => e)),
								(o.style.display = "flex"),
								m && (o.style.flexDirection = "column"),
								(o.innerHTML = ""),
								s.forEach((e) => {
									o.append(e);
								}),
								s.forEach((e) => {
									m
										? (e.style.marginBottom = `${v}px`)
										: ((e.style.marginRight = `${v}px`),
										  (e.style.flexShrink = 0));
									const t = a(e, m);
									return (y += t + v), (w += t + v), (E += t + v), (T += 1), t;
								});
							const i = 2 * t + E;
							for (; y < i; x += 1) {
								s[x] || (x = 0);
								const e = s[x].cloneNode(!0),
									i = o.children[x];
								o.append(e),
									(y += a(i, m) + v),
									(w < t || T % S != 0) && ((T += 1), (w += a(i, m) + v));
							}
							((e) => {
								let t = "display: flex; flex-wrap: nowrap;";
								m
									? ((t +=
											"\n\t\t\t\tflex-direction: column;\n\t\t\t position: relative;\n\t\t\t will-change: transform;"),
									  "bottom" === h && (t += `top: -${e}px;`))
									: ((t +=
											"\n\t\t\t\tposition: relative;\n\t\t\t will-change: transform;"),
									  "right" === h && (t += `left: -${e}px;;`)),
									(o.style.cssText = t);
							})(w);
						},
						A = () => {
							g &&
								(d.forEach((e) => e.style.removeProperty("margin-right")),
								(g = parseFloat(
									window
										.getComputedStyle(d[0])
										.getPropertyValue("margin-right"),
								)),
								(v = g || (isNaN(c) ? 30 : c))),
								O(),
								C(),
								b && o.addEventListener("animationiteration", L),
								u &&
									(o.removeEventListener("mouseenter", k),
									o.removeEventListener("mouseleave", k),
									o.addEventListener("mouseenter", k),
									o.addEventListener("mouseleave", k));
						},
						M = () => {
							r.querySelector(`.${f}`)?.remove(), A();
						},
						k = (e) => {
							const { type: t, target: s } = e;
							s.style.animationPlayState =
								"mouseenter" === t ? "paused" : "running";
						};
					n(M);
				});
			})();
			function h(e) {
				return (
					null !== e &&
					"object" == typeof e &&
					"constructor" in e &&
					e.constructor === Object
				);
			}
			function m(e, t) {
				void 0 === e && (e = {}), void 0 === t && (t = {});
				const s = ["__proto__", "constructor", "prototype"];
				Object.keys(t)
					.filter((e) => s.indexOf(e) < 0)
					.forEach((s) => {
						void 0 === e[s]
							? (e[s] = t[s])
							: h(t[s]) &&
							  h(e[s]) &&
							  Object.keys(t[s]).length > 0 &&
							  m(e[s], t[s]);
					});
			}
			e.ba = new (class {
				constructor(e) {
					(this.config = Object.assign({ init: !0, logging: !1 }, e)),
						this.config.init && ((this.instances = []), this.init());
				}
				init() {
					const e = document.querySelectorAll("[data-ba]");
					e.length > 0 &&
						(this.setLogging(`Found ${e.length} elements`), this.initItems(e));
				}
				initItems(e) {
					e.forEach((e, t) => {
						if (!e) return;
						const s = {
							element: e,
							id: t,
							position: 50,
							isDragging: !1,
							wasDragging: !1,
							arrow: e.querySelector("[data-ba-arrow]"),
							after: e.querySelector("[data-ba-after]"),
							isInitialized: !1,
						};
						if (!s.arrow || !s.after) return;
						this.instances.push(s), this.setupElement(s), this.bindEvents(s);
						const i = this.getSavedPosition(s);
						this.updatePosition(s, i), (s.isInitialized = !0);
					});
				}
				getSavedPosition(e) {
					const t = e.after,
						s = window.getComputedStyle(t),
						i = parseFloat(s.width),
						r = t.parentElement.offsetWidth;
					if (r > 0 && i > 0) {
						const e = 100 - (i / r) * 100;
						if (Math.abs(e - 50) > 1) return e;
					}
					return 50;
				}
				setupElement(e) {
					const { arrow: t, element: s } = e;
					(t.style.touchAction = "none"),
						(t.style.userSelect = "none"),
						(t.style.webkitUserSelect = "none"),
						(t.style.msUserSelect = "none"),
						(t.style.webkitTouchCallout = "none"),
						(t.style.webkitTapHighlightColor = "transparent"),
						(t.style.cursor = "ew-resize"),
						(s.style.webkitUserSelect = "none"),
						(s.style.userSelect = "none"),
						s.setAttribute("tabindex", "0");
				}
				bindEvents(e) {
					const { arrow: t, element: s } = e,
						i = window.innerWidth <= 768,
						r = i ? s : t;
					r.addEventListener("touchstart", (t) => this.onStart(t, e), {
						passive: !1,
					}),
						r.addEventListener("touchmove", (t) => this.onMove(t, e), {
							passive: !1,
						}),
						r.addEventListener("touchend", (t) => this.onEnd(t, e), {
							passive: !1,
						}),
						r.addEventListener("touchcancel", (t) => this.onEnd(t, e), {
							passive: !1,
						}),
						i || t.addEventListener("mousedown", (t) => this.onStart(t, e)),
						i && s.addEventListener("click", (t) => this.onSimpleClick(t, e)),
						t.addEventListener("dragstart", (e) => e.preventDefault()),
						t.addEventListener("contextmenu", (e) => e.preventDefault()),
						s.addEventListener("keydown", (t) => this.onKeyboard(t, e)),
						s.addEventListener("dblclick", () => this.reset(e)),
						s.addEventListener("focus", () => this.onFocus(e)),
						s.addEventListener("blur", () => this.onBlur(e));
				}
				onFocus(e) {
					this.stopScrollHint(), this.saveCurrentPosition(e);
				}
				onBlur(e) {
					this.stopScrollHint(), this.saveCurrentPosition(e);
				}
				saveCurrentPosition(e) {
					e.element.setAttribute("data-ba-position", e.position.toString());
				}
				onStart(e, t) {
					e.preventDefault(),
						e.stopPropagation(),
						this.stopScrollHint(),
						(t.isDragging = !0),
						(t.wasDragging = !1),
						t.element.classList.add("_dragging"),
						this.saveCurrentPosition(t),
						"mousedown" === e.type &&
							((this.mouseMoveHandler = (e) => this.onMove(e, t)),
							(this.mouseUpHandler = (e) => this.onEnd(e, t)),
							document.addEventListener("mousemove", this.mouseMoveHandler),
							document.addEventListener("mouseup", this.mouseUpHandler));
				}
				onMove(e, t) {
					if (!t.isDragging) return;
					e.preventDefault(), e.stopPropagation(), (t.wasDragging = !0);
					const s = t.element.getBoundingClientRect(),
						i = this.getClientX(e) - s.left,
						r = Math.max(0, Math.min(100, (i / s.width) * 100));
					this.updatePosition(t, r);
				}
				onEnd(e, t) {
					t.isDragging &&
						(e.preventDefault(),
						e.stopPropagation(),
						(t.isDragging = !1),
						t.element.classList.remove("_dragging"),
						this.saveCurrentPosition(t),
						this.mouseMoveHandler &&
							(document.removeEventListener("mousemove", this.mouseMoveHandler),
							document.removeEventListener("mouseup", this.mouseUpHandler),
							(this.mouseMoveHandler = null),
							(this.mouseUpHandler = null)),
						setTimeout(() => {
							t.wasDragging = !1;
						}, 100));
				}
				onKeyboard(e, t) {
					let s = t.position;
					switch (e.key) {
						case "ArrowLeft":
							e.preventDefault(), (s = Math.max(0, t.position - 5));
							break;
						case "ArrowRight":
							e.preventDefault(), (s = Math.min(100, t.position + 5));
							break;
						case "Home":
							e.preventDefault(), (s = 0);
							break;
						case "End":
							e.preventDefault(), (s = 100);
							break;
						case " ":
						case "Enter":
							e.preventDefault(), (s = 50);
							break;
						default:
							return;
					}
					this.updatePosition(t, s), this.saveCurrentPosition(t);
				}
				reset(e) {
					this.updatePosition(e, 50), this.saveCurrentPosition(e);
				}
				updatePosition(e, t) {
					e.position = t;
					const { arrow: s, after: i } = e,
						r = s.offsetWidth;
					(s.style.left = `calc(${t}% - ${r / 2}px)`),
						(i.style.width = 100 - t + "%"),
						e.isInitialized && this.saveCurrentPosition(e);
				}
				getClientX(e) {
					return e.touches && e.touches.length > 0
						? e.touches[0].clientX
						: e.changedTouches && e.changedTouches.length > 0
						? e.changedTouches[0].clientX
						: e.clientX || 0;
				}
				setLogging(e) {
					this.config.logging && console.log(`[BeforeAfter]: ${e}`);
				}
				destroy() {
					this.instances.forEach((e) => {
						e.element.classList.remove("_dragging");
					}),
						(this.instances = []);
				}
				stopScrollHint() {
					window.scrollHintManager && window.scrollHintManager.hideAll();
				}
				onSimpleClick(e, t) {
					if (t.wasDragging) return void (t.wasDragging = !1);
					e.preventDefault(), e.stopPropagation();
					const s = t.element.getBoundingClientRect(),
						i = this.getClientX(e) - s.left,
						r = Math.max(0, Math.min(100, (i / s.width) * 100));
					this.animateToPosition(t, r);
				}
				animateToPosition(e, t) {
					const s = e.position,
						i = t - s,
						r = performance.now(),
						n = (t) => {
							const a = t - r,
								o = Math.min(a / 300, 1),
								l = 1 - Math.pow(1 - o, 3),
								c = s + i * l;
							this.updatePosition(e, c),
								o < 1 ? requestAnimationFrame(n) : this.saveCurrentPosition(e);
						};
					requestAnimationFrame(n);
				}
			})({ logging: !1 });
			const f = {
				body: {},
				addEventListener() {},
				removeEventListener() {},
				activeElement: { blur() {}, nodeName: "" },
				querySelector: () => null,
				querySelectorAll: () => [],
				getElementById: () => null,
				createEvent: () => ({ initEvent() {} }),
				createElement: () => ({
					children: [],
					childNodes: [],
					style: {},
					setAttribute() {},
					getElementsByTagName: () => [],
				}),
				createElementNS: () => ({}),
				importNode: () => null,
				location: {
					hash: "",
					host: "",
					hostname: "",
					href: "",
					origin: "",
					pathname: "",
					protocol: "",
					search: "",
				},
			};
			function g() {
				const e = "undefined" != typeof document ? document : {};
				return m(e, f), e;
			}
			const v = {
				document: f,
				navigator: { userAgent: "" },
				location: {
					hash: "",
					host: "",
					hostname: "",
					href: "",
					origin: "",
					pathname: "",
					protocol: "",
					search: "",
				},
				history: { replaceState() {}, pushState() {}, go() {}, back() {} },
				CustomEvent: function () {
					return this;
				},
				addEventListener() {},
				removeEventListener() {},
				getComputedStyle: () => ({ getPropertyValue: () => "" }),
				Image() {},
				Date() {},
				screen: {},
				setTimeout() {},
				clearTimeout() {},
				matchMedia: () => ({}),
				requestAnimationFrame: (e) =>
					"undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0),
				cancelAnimationFrame(e) {
					"undefined" != typeof setTimeout && clearTimeout(e);
				},
			};
			function b() {
				const e = "undefined" != typeof window ? window : {};
				return m(e, v), e;
			}
			function y(e) {
				return (
					void 0 === e && (e = ""),
					e
						.trim()
						.split(" ")
						.filter((e) => !!e.trim())
				);
			}
			function w(e, t) {
				return void 0 === t && (t = 0), setTimeout(e, t);
			}
			function E() {
				return Date.now();
			}
			function S(e, t) {
				void 0 === t && (t = "x");
				const s = b();
				let i, r, n;
				const a = (function (e) {
					const t = b();
					let s;
					return (
						t.getComputedStyle && (s = t.getComputedStyle(e, null)),
						!s && e.currentStyle && (s = e.currentStyle),
						s || (s = e.style),
						s
					);
				})(e);
				return (
					s.WebKitCSSMatrix
						? ((r = a.transform || a.webkitTransform),
						  r.split(",").length > 6 &&
								(r = r
									.split(", ")
									.map((e) => e.replace(",", "."))
									.join(", ")),
						  (n = new s.WebKitCSSMatrix("none" === r ? "" : r)))
						: ((n =
								a.MozTransform ||
								a.OTransform ||
								a.MsTransform ||
								a.msTransform ||
								a.transform ||
								a
									.getPropertyValue("transform")
									.replace("translate(", "matrix(1, 0, 0, 1,")),
						  (i = n.toString().split(","))),
					"x" === t &&
						(r = s.WebKitCSSMatrix
							? n.m41
							: 16 === i.length
							? parseFloat(i[12])
							: parseFloat(i[4])),
					"y" === t &&
						(r = s.WebKitCSSMatrix
							? n.m42
							: 16 === i.length
							? parseFloat(i[13])
							: parseFloat(i[5])),
					r || 0
				);
			}
			function x(e) {
				return (
					"object" == typeof e &&
					null !== e &&
					e.constructor &&
					"Object" === Object.prototype.toString.call(e).slice(8, -1)
				);
			}
			function T() {
				const e = Object(arguments.length <= 0 ? void 0 : arguments[0]),
					t = ["__proto__", "constructor", "prototype"];
				for (let i = 1; i < arguments.length; i += 1) {
					const r = i < 0 || arguments.length <= i ? void 0 : arguments[i];
					if (
						null != r &&
						((s = r),
						!("undefined" != typeof window && void 0 !== window.HTMLElement
							? s instanceof HTMLElement
							: s && (1 === s.nodeType || 11 === s.nodeType)))
					) {
						const s = Object.keys(Object(r)).filter((e) => t.indexOf(e) < 0);
						for (let t = 0, i = s.length; t < i; t += 1) {
							const i = s[t],
								n = Object.getOwnPropertyDescriptor(r, i);
							void 0 !== n &&
								n.enumerable &&
								(x(e[i]) && x(r[i])
									? r[i].__swiper__
										? (e[i] = r[i])
										: T(e[i], r[i])
									: !x(e[i]) && x(r[i])
									? ((e[i] = {}),
									  r[i].__swiper__ ? (e[i] = r[i]) : T(e[i], r[i]))
									: (e[i] = r[i]));
						}
					}
				}
				var s;
				return e;
			}
			function L(e, t, s) {
				e.style.setProperty(t, s);
			}
			function C(e) {
				let { swiper: t, targetPosition: s, side: i } = e;
				const r = b(),
					n = -t.translate;
				let a,
					o = null;
				const l = t.params.speed;
				(t.wrapperEl.style.scrollSnapType = "none"),
					r.cancelAnimationFrame(t.cssModeFrameID);
				const c = s > n ? "next" : "prev",
					d = (e, t) => ("next" === c && e >= t) || ("prev" === c && e <= t),
					p = () => {
						(a = new Date().getTime()), null === o && (o = a);
						const e = Math.max(Math.min((a - o) / l, 1), 0),
							c = 0.5 - Math.cos(e * Math.PI) / 2;
						let u = n + c * (s - n);
						if ((d(u, s) && (u = s), t.wrapperEl.scrollTo({ [i]: u }), d(u, s)))
							return (
								(t.wrapperEl.style.overflow = "hidden"),
								(t.wrapperEl.style.scrollSnapType = ""),
								setTimeout(() => {
									(t.wrapperEl.style.overflow = ""),
										t.wrapperEl.scrollTo({ [i]: u });
								}),
								void r.cancelAnimationFrame(t.cssModeFrameID)
							);
						t.cssModeFrameID = r.requestAnimationFrame(p);
					};
				p();
			}
			function O(e, t) {
				void 0 === t && (t = "");
				const s = b(),
					i = [...e.children];
				return (
					s.HTMLSlotElement &&
						e instanceof HTMLSlotElement &&
						i.push(...e.assignedElements()),
					t ? i.filter((e) => e.matches(t)) : i
				);
			}
			function A(e) {
				try {
					return void console.warn(e);
				} catch (e) {}
			}
			function M(e, t) {
				void 0 === t && (t = []);
				const s = document.createElement(e);
				return s.classList.add(...(Array.isArray(t) ? t : y(t))), s;
			}
			function k(e, t) {
				return b().getComputedStyle(e, null).getPropertyValue(t);
			}
			function _(e) {
				let t,
					s = e;
				if (s) {
					for (t = 0; null !== (s = s.previousSibling); )
						1 === s.nodeType && (t += 1);
					return t;
				}
			}
			function P(e, t) {
				const s = [];
				let i = e.parentElement;
				for (; i; )
					t ? i.matches(t) && s.push(i) : s.push(i), (i = i.parentElement);
				return s;
			}
			function z(e, t, s) {
				const i = b();
				return s
					? e["width" === t ? "offsetWidth" : "offsetHeight"] +
							parseFloat(
								i
									.getComputedStyle(e, null)
									.getPropertyValue(
										"width" === t ? "margin-right" : "margin-top",
									),
							) +
							parseFloat(
								i
									.getComputedStyle(e, null)
									.getPropertyValue(
										"width" === t ? "margin-left" : "margin-bottom",
									),
							)
					: e.offsetWidth;
			}
			function I(e) {
				return (Array.isArray(e) ? e : [e]).filter((e) => !!e);
			}
			let D, $, B;
			function W() {
				return (
					D ||
						(D = (function () {
							const e = b(),
								t = g();
							return {
								smoothScroll:
									t.documentElement &&
									t.documentElement.style &&
									"scrollBehavior" in t.documentElement.style,
								touch: !!(
									"ontouchstart" in e ||
									(e.DocumentTouch && t instanceof e.DocumentTouch)
								),
							};
						})()),
					D
				);
			}
			function N(e) {
				return (
					void 0 === e && (e = {}),
					$ ||
						($ = (function (e) {
							let { userAgent: t } = void 0 === e ? {} : e;
							const s = W(),
								i = b(),
								r = i.navigator.platform,
								n = t || i.navigator.userAgent,
								a = { ios: !1, android: !1 },
								o = i.screen.width,
								l = i.screen.height,
								c = n.match(/(Android);?[\s\/]+([\d.]+)?/);
							let d = n.match(/(iPad).*OS\s([\d_]+)/);
							const p = n.match(/(iPod)(.*OS\s([\d_]+))?/),
								u = !d && n.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
								h = "Win32" === r;
							let m = "MacIntel" === r;
							return (
								!d &&
									m &&
									s.touch &&
									[
										"1024x1366",
										"1366x1024",
										"834x1194",
										"1194x834",
										"834x1112",
										"1112x834",
										"768x1024",
										"1024x768",
										"820x1180",
										"1180x820",
										"810x1080",
										"1080x810",
									].indexOf(`${o}x${l}`) >= 0 &&
									((d = n.match(/(Version)\/([\d.]+)/)),
									d || (d = [0, 1, "13_0_0"]),
									(m = !1)),
								c && !h && ((a.os = "android"), (a.android = !0)),
								(d || u || p) && ((a.os = "ios"), (a.ios = !0)),
								a
							);
						})(e)),
					$
				);
			}
			function q() {
				return (
					B ||
						(B = (function () {
							const e = b(),
								t = N();
							let s = !1;
							function i() {
								const t = e.navigator.userAgent.toLowerCase();
								return (
									t.indexOf("safari") >= 0 &&
									t.indexOf("chrome") < 0 &&
									t.indexOf("android") < 0
								);
							}
							if (i()) {
								const t = String(e.navigator.userAgent);
								if (t.includes("Version/")) {
									const [e, i] = t
										.split("Version/")[1]
										.split(" ")[0]
										.split(".")
										.map((e) => Number(e));
									s = e < 16 || (16 === e && i < 2);
								}
							}
							const r = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
									e.navigator.userAgent,
								),
								n = i();
							return {
								isSafari: s || n,
								needPerspectiveFix: s,
								need3dFix: n || (r && t.ios),
								isWebView: r,
							};
						})()),
					B
				);
			}
			var H = {
				on(e, t, s) {
					const i = this;
					if (!i.eventsListeners || i.destroyed) return i;
					if ("function" != typeof t) return i;
					const r = s ? "unshift" : "push";
					return (
						e.split(" ").forEach((e) => {
							i.eventsListeners[e] || (i.eventsListeners[e] = []),
								i.eventsListeners[e][r](t);
						}),
						i
					);
				},
				once(e, t, s) {
					const i = this;
					if (!i.eventsListeners || i.destroyed) return i;
					if ("function" != typeof t) return i;
					function r() {
						i.off(e, r), r.__emitterProxy && delete r.__emitterProxy;
						for (var s = arguments.length, n = new Array(s), a = 0; a < s; a++)
							n[a] = arguments[a];
						t.apply(i, n);
					}
					return (r.__emitterProxy = t), i.on(e, r, s);
				},
				onAny(e, t) {
					const s = this;
					if (!s.eventsListeners || s.destroyed) return s;
					if ("function" != typeof e) return s;
					const i = t ? "unshift" : "push";
					return (
						s.eventsAnyListeners.indexOf(e) < 0 && s.eventsAnyListeners[i](e), s
					);
				},
				offAny(e) {
					const t = this;
					if (!t.eventsListeners || t.destroyed) return t;
					if (!t.eventsAnyListeners) return t;
					const s = t.eventsAnyListeners.indexOf(e);
					return s >= 0 && t.eventsAnyListeners.splice(s, 1), t;
				},
				off(e, t) {
					const s = this;
					return !s.eventsListeners || s.destroyed
						? s
						: s.eventsListeners
						? (e.split(" ").forEach((e) => {
								void 0 === t
									? (s.eventsListeners[e] = [])
									: s.eventsListeners[e] &&
									  s.eventsListeners[e].forEach((i, r) => {
											(i === t ||
												(i.__emitterProxy && i.__emitterProxy === t)) &&
												s.eventsListeners[e].splice(r, 1);
									  });
						  }),
						  s)
						: s;
				},
				emit() {
					const e = this;
					if (!e.eventsListeners || e.destroyed) return e;
					if (!e.eventsListeners) return e;
					let t, s, i;
					for (var r = arguments.length, n = new Array(r), a = 0; a < r; a++)
						n[a] = arguments[a];
					"string" == typeof n[0] || Array.isArray(n[0])
						? ((t = n[0]), (s = n.slice(1, n.length)), (i = e))
						: ((t = n[0].events), (s = n[0].data), (i = n[0].context || e)),
						s.unshift(i);
					return (
						(Array.isArray(t) ? t : t.split(" ")).forEach((t) => {
							e.eventsAnyListeners &&
								e.eventsAnyListeners.length &&
								e.eventsAnyListeners.forEach((e) => {
									e.apply(i, [t, ...s]);
								}),
								e.eventsListeners &&
									e.eventsListeners[t] &&
									e.eventsListeners[t].forEach((e) => {
										e.apply(i, s);
									});
						}),
						e
					);
				},
			};
			const V = (e, t, s) => {
				t && !e.classList.contains(s)
					? e.classList.add(s)
					: !t && e.classList.contains(s) && e.classList.remove(s);
			};
			const G = (e, t, s) => {
				t && !e.classList.contains(s)
					? e.classList.add(s)
					: !t && e.classList.contains(s) && e.classList.remove(s);
			};
			const F = (e, t) => {
					if (!e || e.destroyed || !e.params) return;
					const s = t.closest(
						e.isElement ? "swiper-slide" : `.${e.params.slideClass}`,
					);
					if (s) {
						let t = s.querySelector(`.${e.params.lazyPreloaderClass}`);
						!t &&
							e.isElement &&
							(s.shadowRoot
								? (t = s.shadowRoot.querySelector(
										`.${e.params.lazyPreloaderClass}`,
								  ))
								: requestAnimationFrame(() => {
										s.shadowRoot &&
											((t = s.shadowRoot.querySelector(
												`.${e.params.lazyPreloaderClass}`,
											)),
											t && t.remove());
								  })),
							t && t.remove();
					}
				},
				R = (e, t) => {
					if (!e.slides[t]) return;
					const s = e.slides[t].querySelector('[loading="lazy"]');
					s && s.removeAttribute("loading");
				},
				j = (e) => {
					if (!e || e.destroyed || !e.params) return;
					let t = e.params.lazyPreloadPrevNext;
					const s = e.slides.length;
					if (!s || !t || t < 0) return;
					t = Math.min(t, s);
					const i =
							"auto" === e.params.slidesPerView
								? e.slidesPerViewDynamic()
								: Math.ceil(e.params.slidesPerView),
						r = e.activeIndex;
					if (e.params.grid && e.params.grid.rows > 1) {
						const s = r,
							n = [s - t];
						return (
							n.push(...Array.from({ length: t }).map((e, t) => s + i + t)),
							void e.slides.forEach((t, s) => {
								n.includes(t.column) && R(e, s);
							})
						);
					}
					const n = r + i - 1;
					if (e.params.rewind || e.params.loop)
						for (let i = r - t; i <= n + t; i += 1) {
							const t = ((i % s) + s) % s;
							(t < r || t > n) && R(e, t);
						}
					else
						for (
							let i = Math.max(r - t, 0);
							i <= Math.min(n + t, s - 1);
							i += 1
						)
							i !== r && (i > n || i < r) && R(e, i);
				};
			var Y = {
				updateSize: function () {
					const e = this;
					let t, s;
					const i = e.el;
					(t =
						void 0 !== e.params.width && null !== e.params.width
							? e.params.width
							: i.clientWidth),
						(s =
							void 0 !== e.params.height && null !== e.params.height
								? e.params.height
								: i.clientHeight),
						(0 === t && e.isHorizontal()) ||
							(0 === s && e.isVertical()) ||
							((t =
								t -
								parseInt(k(i, "padding-left") || 0, 10) -
								parseInt(k(i, "padding-right") || 0, 10)),
							(s =
								s -
								parseInt(k(i, "padding-top") || 0, 10) -
								parseInt(k(i, "padding-bottom") || 0, 10)),
							Number.isNaN(t) && (t = 0),
							Number.isNaN(s) && (s = 0),
							Object.assign(e, {
								width: t,
								height: s,
								size: e.isHorizontal() ? t : s,
							}));
				},
				updateSlides: function () {
					const e = this;
					function t(t, s) {
						return parseFloat(t.getPropertyValue(e.getDirectionLabel(s)) || 0);
					}
					const s = e.params,
						{
							wrapperEl: i,
							slidesEl: r,
							size: n,
							rtlTranslate: a,
							wrongRTL: o,
						} = e,
						l = e.virtual && s.virtual.enabled,
						c = l ? e.virtual.slides.length : e.slides.length,
						d = O(r, `.${e.params.slideClass}, swiper-slide`),
						p = l ? e.virtual.slides.length : d.length;
					let u = [];
					const h = [],
						m = [];
					let f = s.slidesOffsetBefore;
					"function" == typeof f && (f = s.slidesOffsetBefore.call(e));
					let g = s.slidesOffsetAfter;
					"function" == typeof g && (g = s.slidesOffsetAfter.call(e));
					const v = e.snapGrid.length,
						b = e.slidesGrid.length;
					let y = s.spaceBetween,
						w = -f,
						E = 0,
						S = 0;
					if (void 0 === n) return;
					"string" == typeof y && y.indexOf("%") >= 0
						? (y = (parseFloat(y.replace("%", "")) / 100) * n)
						: "string" == typeof y && (y = parseFloat(y)),
						(e.virtualSize = -y),
						d.forEach((e) => {
							a ? (e.style.marginLeft = "") : (e.style.marginRight = ""),
								(e.style.marginBottom = ""),
								(e.style.marginTop = "");
						}),
						s.centeredSlides &&
							s.cssMode &&
							(L(i, "--swiper-centered-offset-before", ""),
							L(i, "--swiper-centered-offset-after", ""));
					const x = s.grid && s.grid.rows > 1 && e.grid;
					let T;
					x ? e.grid.initSlides(d) : e.grid && e.grid.unsetSlides();
					const C =
						"auto" === s.slidesPerView &&
						s.breakpoints &&
						Object.keys(s.breakpoints).filter(
							(e) => void 0 !== s.breakpoints[e].slidesPerView,
						).length > 0;
					for (let i = 0; i < p; i += 1) {
						let r;
						if (
							((T = 0),
							d[i] && (r = d[i]),
							x && e.grid.updateSlide(i, r, d),
							!d[i] || "none" !== k(r, "display"))
						) {
							if ("auto" === s.slidesPerView) {
								C && (d[i].style[e.getDirectionLabel("width")] = "");
								const n = getComputedStyle(r),
									a = r.style.transform,
									o = r.style.webkitTransform;
								if (
									(a && (r.style.transform = "none"),
									o && (r.style.webkitTransform = "none"),
									s.roundLengths)
								)
									T = e.isHorizontal() ? z(r, "width", !0) : z(r, "height", !0);
								else {
									const e = t(n, "width"),
										s = t(n, "padding-left"),
										i = t(n, "padding-right"),
										a = t(n, "margin-left"),
										o = t(n, "margin-right"),
										l = n.getPropertyValue("box-sizing");
									if (l && "border-box" === l) T = e + a + o;
									else {
										const { clientWidth: t, offsetWidth: n } = r;
										T = e + s + i + a + o + (n - t);
									}
								}
								a && (r.style.transform = a),
									o && (r.style.webkitTransform = o),
									s.roundLengths && (T = Math.floor(T));
							} else
								(T = (n - (s.slidesPerView - 1) * y) / s.slidesPerView),
									s.roundLengths && (T = Math.floor(T)),
									d[i] && (d[i].style[e.getDirectionLabel("width")] = `${T}px`);
							d[i] && (d[i].swiperSlideSize = T),
								m.push(T),
								s.centeredSlides
									? ((w = w + T / 2 + E / 2 + y),
									  0 === E && 0 !== i && (w = w - n / 2 - y),
									  0 === i && (w = w - n / 2 - y),
									  Math.abs(w) < 0.001 && (w = 0),
									  s.roundLengths && (w = Math.floor(w)),
									  S % s.slidesPerGroup == 0 && u.push(w),
									  h.push(w))
									: (s.roundLengths && (w = Math.floor(w)),
									  (S - Math.min(e.params.slidesPerGroupSkip, S)) %
											e.params.slidesPerGroup ==
											0 && u.push(w),
									  h.push(w),
									  (w = w + T + y)),
								(e.virtualSize += T + y),
								(E = T),
								(S += 1);
						}
					}
					if (
						((e.virtualSize = Math.max(e.virtualSize, n) + g),
						a &&
							o &&
							("slide" === s.effect || "coverflow" === s.effect) &&
							(i.style.width = `${e.virtualSize + y}px`),
						s.setWrapperSize &&
							(i.style[e.getDirectionLabel("width")] = `${
								e.virtualSize + y
							}px`),
						x && e.grid.updateWrapperSize(T, u),
						!s.centeredSlides)
					) {
						const t = [];
						for (let i = 0; i < u.length; i += 1) {
							let r = u[i];
							s.roundLengths && (r = Math.floor(r)),
								u[i] <= e.virtualSize - n && t.push(r);
						}
						(u = t),
							Math.floor(e.virtualSize - n) - Math.floor(u[u.length - 1]) > 1 &&
								u.push(e.virtualSize - n);
					}
					if (l && s.loop) {
						const t = m[0] + y;
						if (s.slidesPerGroup > 1) {
							const i = Math.ceil(
									(e.virtual.slidesBefore + e.virtual.slidesAfter) /
										s.slidesPerGroup,
								),
								r = t * s.slidesPerGroup;
							for (let e = 0; e < i; e += 1) u.push(u[u.length - 1] + r);
						}
						for (
							let i = 0;
							i < e.virtual.slidesBefore + e.virtual.slidesAfter;
							i += 1
						)
							1 === s.slidesPerGroup && u.push(u[u.length - 1] + t),
								h.push(h[h.length - 1] + t),
								(e.virtualSize += t);
					}
					if ((0 === u.length && (u = [0]), 0 !== y)) {
						const t =
							e.isHorizontal() && a
								? "marginLeft"
								: e.getDirectionLabel("marginRight");
						d.filter(
							(e, t) => !(s.cssMode && !s.loop) || t !== d.length - 1,
						).forEach((e) => {
							e.style[t] = `${y}px`;
						});
					}
					if (s.centeredSlides && s.centeredSlidesBounds) {
						let e = 0;
						m.forEach((t) => {
							e += t + (y || 0);
						}),
							(e -= y);
						const t = e > n ? e - n : 0;
						u = u.map((e) => (e <= 0 ? -f : e > t ? t + g : e));
					}
					if (s.centerInsufficientSlides) {
						let e = 0;
						m.forEach((t) => {
							e += t + (y || 0);
						}),
							(e -= y);
						const t = (s.slidesOffsetBefore || 0) + (s.slidesOffsetAfter || 0);
						if (e + t < n) {
							const s = (n - e - t) / 2;
							u.forEach((e, t) => {
								u[t] = e - s;
							}),
								h.forEach((e, t) => {
									h[t] = e + s;
								});
						}
					}
					if (
						(Object.assign(e, {
							slides: d,
							snapGrid: u,
							slidesGrid: h,
							slidesSizesGrid: m,
						}),
						s.centeredSlides && s.cssMode && !s.centeredSlidesBounds)
					) {
						L(i, "--swiper-centered-offset-before", -u[0] + "px"),
							L(
								i,
								"--swiper-centered-offset-after",
								e.size / 2 - m[m.length - 1] / 2 + "px",
							);
						const t = -e.snapGrid[0],
							s = -e.slidesGrid[0];
						(e.snapGrid = e.snapGrid.map((e) => e + t)),
							(e.slidesGrid = e.slidesGrid.map((e) => e + s));
					}
					if (
						(p !== c && e.emit("slidesLengthChange"),
						u.length !== v &&
							(e.params.watchOverflow && e.checkOverflow(),
							e.emit("snapGridLengthChange")),
						h.length !== b && e.emit("slidesGridLengthChange"),
						s.watchSlidesProgress && e.updateSlidesOffset(),
						e.emit("slidesUpdated"),
						!(l || s.cssMode || ("slide" !== s.effect && "fade" !== s.effect)))
					) {
						const t = `${s.containerModifierClass}backface-hidden`,
							i = e.el.classList.contains(t);
						p <= s.maxBackfaceHiddenSlides
							? i || e.el.classList.add(t)
							: i && e.el.classList.remove(t);
					}
				},
				updateAutoHeight: function (e) {
					const t = this,
						s = [],
						i = t.virtual && t.params.virtual.enabled;
					let r,
						n = 0;
					"number" == typeof e
						? t.setTransition(e)
						: !0 === e && t.setTransition(t.params.speed);
					const a = (e) =>
						i ? t.slides[t.getSlideIndexByData(e)] : t.slides[e];
					if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1)
						if (t.params.centeredSlides)
							(t.visibleSlides || []).forEach((e) => {
								s.push(e);
							});
						else
							for (r = 0; r < Math.ceil(t.params.slidesPerView); r += 1) {
								const e = t.activeIndex + r;
								if (e > t.slides.length && !i) break;
								s.push(a(e));
							}
					else s.push(a(t.activeIndex));
					for (r = 0; r < s.length; r += 1)
						if (void 0 !== s[r]) {
							const e = s[r].offsetHeight;
							n = e > n ? e : n;
						}
					(n || 0 === n) && (t.wrapperEl.style.height = `${n}px`);
				},
				updateSlidesOffset: function () {
					const e = this,
						t = e.slides,
						s = e.isElement
							? e.isHorizontal()
								? e.wrapperEl.offsetLeft
								: e.wrapperEl.offsetTop
							: 0;
					for (let i = 0; i < t.length; i += 1)
						t[i].swiperSlideOffset =
							(e.isHorizontal() ? t[i].offsetLeft : t[i].offsetTop) -
							s -
							e.cssOverflowAdjustment();
				},
				updateSlidesProgress: function (e) {
					void 0 === e && (e = (this && this.translate) || 0);
					const t = this,
						s = t.params,
						{ slides: i, rtlTranslate: r, snapGrid: n } = t;
					if (0 === i.length) return;
					void 0 === i[0].swiperSlideOffset && t.updateSlidesOffset();
					let a = -e;
					r && (a = e), (t.visibleSlidesIndexes = []), (t.visibleSlides = []);
					let o = s.spaceBetween;
					"string" == typeof o && o.indexOf("%") >= 0
						? (o = (parseFloat(o.replace("%", "")) / 100) * t.size)
						: "string" == typeof o && (o = parseFloat(o));
					for (let e = 0; e < i.length; e += 1) {
						const l = i[e];
						let c = l.swiperSlideOffset;
						s.cssMode && s.centeredSlides && (c -= i[0].swiperSlideOffset);
						const d =
								(a + (s.centeredSlides ? t.minTranslate() : 0) - c) /
								(l.swiperSlideSize + o),
							p =
								(a - n[0] + (s.centeredSlides ? t.minTranslate() : 0) - c) /
								(l.swiperSlideSize + o),
							u = -(a - c),
							h = u + t.slidesSizesGrid[e],
							m = u >= 0 && u <= t.size - t.slidesSizesGrid[e],
							f =
								(u >= 0 && u < t.size - 1) ||
								(h > 1 && h <= t.size) ||
								(u <= 0 && h >= t.size);
						f && (t.visibleSlides.push(l), t.visibleSlidesIndexes.push(e)),
							V(l, f, s.slideVisibleClass),
							V(l, m, s.slideFullyVisibleClass),
							(l.progress = r ? -d : d),
							(l.originalProgress = r ? -p : p);
					}
				},
				updateProgress: function (e) {
					const t = this;
					if (void 0 === e) {
						const s = t.rtlTranslate ? -1 : 1;
						e = (t && t.translate && t.translate * s) || 0;
					}
					const s = t.params,
						i = t.maxTranslate() - t.minTranslate();
					let { progress: r, isBeginning: n, isEnd: a, progressLoop: o } = t;
					const l = n,
						c = a;
					if (0 === i) (r = 0), (n = !0), (a = !0);
					else {
						r = (e - t.minTranslate()) / i;
						const s = Math.abs(e - t.minTranslate()) < 1,
							o = Math.abs(e - t.maxTranslate()) < 1;
						(n = s || r <= 0), (a = o || r >= 1), s && (r = 0), o && (r = 1);
					}
					if (s.loop) {
						const s = t.getSlideIndexByData(0),
							i = t.getSlideIndexByData(t.slides.length - 1),
							r = t.slidesGrid[s],
							n = t.slidesGrid[i],
							a = t.slidesGrid[t.slidesGrid.length - 1],
							l = Math.abs(e);
						(o = l >= r ? (l - r) / a : (l + a - n) / a), o > 1 && (o -= 1);
					}
					Object.assign(t, {
						progress: r,
						progressLoop: o,
						isBeginning: n,
						isEnd: a,
					}),
						(s.watchSlidesProgress || (s.centeredSlides && s.autoHeight)) &&
							t.updateSlidesProgress(e),
						n && !l && t.emit("reachBeginning toEdge"),
						a && !c && t.emit("reachEnd toEdge"),
						((l && !n) || (c && !a)) && t.emit("fromEdge"),
						t.emit("progress", r);
				},
				updateSlidesClasses: function () {
					const e = this,
						{ slides: t, params: s, slidesEl: i, activeIndex: r } = e,
						n = e.virtual && s.virtual.enabled,
						a = e.grid && s.grid && s.grid.rows > 1,
						o = (e) => O(i, `.${s.slideClass}${e}, swiper-slide${e}`)[0];
					let l, c, d;
					if (n)
						if (s.loop) {
							let t = r - e.virtual.slidesBefore;
							t < 0 && (t = e.virtual.slides.length + t),
								t >= e.virtual.slides.length && (t -= e.virtual.slides.length),
								(l = o(`[data-swiper-slide-index="${t}"]`));
						} else l = o(`[data-swiper-slide-index="${r}"]`);
					else
						a
							? ((l = t.find((e) => e.column === r)),
							  (d = t.find((e) => e.column === r + 1)),
							  (c = t.find((e) => e.column === r - 1)))
							: (l = t[r]);
					l &&
						(a ||
							((d = (function (e, t) {
								const s = [];
								for (; e.nextElementSibling; ) {
									const i = e.nextElementSibling;
									t ? i.matches(t) && s.push(i) : s.push(i), (e = i);
								}
								return s;
							})(l, `.${s.slideClass}, swiper-slide`)[0]),
							s.loop && !d && (d = t[0]),
							(c = (function (e, t) {
								const s = [];
								for (; e.previousElementSibling; ) {
									const i = e.previousElementSibling;
									t ? i.matches(t) && s.push(i) : s.push(i), (e = i);
								}
								return s;
							})(l, `.${s.slideClass}, swiper-slide`)[0]),
							s.loop && 0 === !c && (c = t[t.length - 1]))),
						t.forEach((e) => {
							G(e, e === l, s.slideActiveClass),
								G(e, e === d, s.slideNextClass),
								G(e, e === c, s.slidePrevClass);
						}),
						e.emitSlidesClasses();
				},
				updateActiveIndex: function (e) {
					const t = this,
						s = t.rtlTranslate ? t.translate : -t.translate,
						{
							snapGrid: i,
							params: r,
							activeIndex: n,
							realIndex: a,
							snapIndex: o,
						} = t;
					let l,
						c = e;
					const d = (e) => {
						let s = e - t.virtual.slidesBefore;
						return (
							s < 0 && (s = t.virtual.slides.length + s),
							s >= t.virtual.slides.length && (s -= t.virtual.slides.length),
							s
						);
					};
					if (
						(void 0 === c &&
							(c = (function (e) {
								const { slidesGrid: t, params: s } = e,
									i = e.rtlTranslate ? e.translate : -e.translate;
								let r;
								for (let e = 0; e < t.length; e += 1)
									void 0 !== t[e + 1]
										? i >= t[e] && i < t[e + 1] - (t[e + 1] - t[e]) / 2
											? (r = e)
											: i >= t[e] && i < t[e + 1] && (r = e + 1)
										: i >= t[e] && (r = e);
								return (
									s.normalizeSlideIndex && (r < 0 || void 0 === r) && (r = 0), r
								);
							})(t)),
						i.indexOf(s) >= 0)
					)
						l = i.indexOf(s);
					else {
						const e = Math.min(r.slidesPerGroupSkip, c);
						l = e + Math.floor((c - e) / r.slidesPerGroup);
					}
					if ((l >= i.length && (l = i.length - 1), c === n && !t.params.loop))
						return void (
							l !== o && ((t.snapIndex = l), t.emit("snapIndexChange"))
						);
					if (c === n && t.params.loop && t.virtual && t.params.virtual.enabled)
						return void (t.realIndex = d(c));
					const p = t.grid && r.grid && r.grid.rows > 1;
					let u;
					if (t.virtual && r.virtual.enabled && r.loop) u = d(c);
					else if (p) {
						const e = t.slides.find((e) => e.column === c);
						let s = parseInt(e.getAttribute("data-swiper-slide-index"), 10);
						Number.isNaN(s) && (s = Math.max(t.slides.indexOf(e), 0)),
							(u = Math.floor(s / r.grid.rows));
					} else if (t.slides[c]) {
						const e = t.slides[c].getAttribute("data-swiper-slide-index");
						u = e ? parseInt(e, 10) : c;
					} else u = c;
					Object.assign(t, {
						previousSnapIndex: o,
						snapIndex: l,
						previousRealIndex: a,
						realIndex: u,
						previousIndex: n,
						activeIndex: c,
					}),
						t.initialized && j(t),
						t.emit("activeIndexChange"),
						t.emit("snapIndexChange"),
						(t.initialized || t.params.runCallbacksOnInit) &&
							(a !== u && t.emit("realIndexChange"), t.emit("slideChange"));
				},
				updateClickedSlide: function (e, t) {
					const s = this,
						i = s.params;
					let r = e.closest(`.${i.slideClass}, swiper-slide`);
					!r &&
						s.isElement &&
						t &&
						t.length > 1 &&
						t.includes(e) &&
						[...t.slice(t.indexOf(e) + 1, t.length)].forEach((e) => {
							!r &&
								e.matches &&
								e.matches(`.${i.slideClass}, swiper-slide`) &&
								(r = e);
						});
					let n,
						a = !1;
					if (r)
						for (let e = 0; e < s.slides.length; e += 1)
							if (s.slides[e] === r) {
								(a = !0), (n = e);
								break;
							}
					if (!r || !a)
						return (s.clickedSlide = void 0), void (s.clickedIndex = void 0);
					(s.clickedSlide = r),
						s.virtual && s.params.virtual.enabled
							? (s.clickedIndex = parseInt(
									r.getAttribute("data-swiper-slide-index"),
									10,
							  ))
							: (s.clickedIndex = n),
						i.slideToClickedSlide &&
							void 0 !== s.clickedIndex &&
							s.clickedIndex !== s.activeIndex &&
							s.slideToClickedSlide();
				},
			};
			var X = {
				getTranslate: function (e) {
					void 0 === e && (e = this.isHorizontal() ? "x" : "y");
					const {
						params: t,
						rtlTranslate: s,
						translate: i,
						wrapperEl: r,
					} = this;
					if (t.virtualTranslate) return s ? -i : i;
					if (t.cssMode) return i;
					let n = S(r, e);
					return (n += this.cssOverflowAdjustment()), s && (n = -n), n || 0;
				},
				setTranslate: function (e, t) {
					const s = this,
						{ rtlTranslate: i, params: r, wrapperEl: n, progress: a } = s;
					let o,
						l = 0,
						c = 0;
					s.isHorizontal() ? (l = i ? -e : e) : (c = e),
						r.roundLengths && ((l = Math.floor(l)), (c = Math.floor(c))),
						(s.previousTranslate = s.translate),
						(s.translate = s.isHorizontal() ? l : c),
						r.cssMode
							? (n[s.isHorizontal() ? "scrollLeft" : "scrollTop"] =
									s.isHorizontal() ? -l : -c)
							: r.virtualTranslate ||
							  (s.isHorizontal()
									? (l -= s.cssOverflowAdjustment())
									: (c -= s.cssOverflowAdjustment()),
							  (n.style.transform = `translate3d(${l}px, ${c}px, 0px)`));
					const d = s.maxTranslate() - s.minTranslate();
					(o = 0 === d ? 0 : (e - s.minTranslate()) / d),
						o !== a && s.updateProgress(e),
						s.emit("setTranslate", s.translate, t);
				},
				minTranslate: function () {
					return -this.snapGrid[0];
				},
				maxTranslate: function () {
					return -this.snapGrid[this.snapGrid.length - 1];
				},
				translateTo: function (e, t, s, i, r) {
					void 0 === e && (e = 0),
						void 0 === t && (t = this.params.speed),
						void 0 === s && (s = !0),
						void 0 === i && (i = !0);
					const n = this,
						{ params: a, wrapperEl: o } = n;
					if (n.animating && a.preventInteractionOnTransition) return !1;
					const l = n.minTranslate(),
						c = n.maxTranslate();
					let d;
					if (
						((d = i && e > l ? l : i && e < c ? c : e),
						n.updateProgress(d),
						a.cssMode)
					) {
						const e = n.isHorizontal();
						if (0 === t) o[e ? "scrollLeft" : "scrollTop"] = -d;
						else {
							if (!n.support.smoothScroll)
								return (
									C({
										swiper: n,
										targetPosition: -d,
										side: e ? "left" : "top",
									}),
									!0
								);
							o.scrollTo({ [e ? "left" : "top"]: -d, behavior: "smooth" });
						}
						return !0;
					}
					return (
						0 === t
							? (n.setTransition(0),
							  n.setTranslate(d),
							  s &&
									(n.emit("beforeTransitionStart", t, r),
									n.emit("transitionEnd")))
							: (n.setTransition(t),
							  n.setTranslate(d),
							  s &&
									(n.emit("beforeTransitionStart", t, r),
									n.emit("transitionStart")),
							  n.animating ||
									((n.animating = !0),
									n.onTranslateToWrapperTransitionEnd ||
										(n.onTranslateToWrapperTransitionEnd = function (e) {
											n &&
												!n.destroyed &&
												e.target === this &&
												(n.wrapperEl.removeEventListener(
													"transitionend",
													n.onTranslateToWrapperTransitionEnd,
												),
												(n.onTranslateToWrapperTransitionEnd = null),
												delete n.onTranslateToWrapperTransitionEnd,
												(n.animating = !1),
												s && n.emit("transitionEnd"));
										}),
									n.wrapperEl.addEventListener(
										"transitionend",
										n.onTranslateToWrapperTransitionEnd,
									))),
						!0
					);
				},
			};
			function U(e) {
				let { swiper: t, runCallbacks: s, direction: i, step: r } = e;
				const { activeIndex: n, previousIndex: a } = t;
				let o = i;
				if (
					(o || (o = n > a ? "next" : n < a ? "prev" : "reset"),
					t.emit(`transition${r}`),
					s && n !== a)
				) {
					if ("reset" === o) return void t.emit(`slideResetTransition${r}`);
					t.emit(`slideChangeTransition${r}`),
						"next" === o
							? t.emit(`slideNextTransition${r}`)
							: t.emit(`slidePrevTransition${r}`);
				}
			}
			var K = {
				slideTo: function (e, t, s, i, r) {
					void 0 === e && (e = 0),
						void 0 === s && (s = !0),
						"string" == typeof e && (e = parseInt(e, 10));
					const n = this;
					let a = e;
					a < 0 && (a = 0);
					const {
						params: o,
						snapGrid: l,
						slidesGrid: c,
						previousIndex: d,
						activeIndex: p,
						rtlTranslate: u,
						wrapperEl: h,
						enabled: m,
					} = n;
					if (
						(!m && !i && !r) ||
						n.destroyed ||
						(n.animating && o.preventInteractionOnTransition)
					)
						return !1;
					void 0 === t && (t = n.params.speed);
					const f = Math.min(n.params.slidesPerGroupSkip, a);
					let g = f + Math.floor((a - f) / n.params.slidesPerGroup);
					g >= l.length && (g = l.length - 1);
					const v = -l[g];
					if (o.normalizeSlideIndex)
						for (let e = 0; e < c.length; e += 1) {
							const t = -Math.floor(100 * v),
								s = Math.floor(100 * c[e]),
								i = Math.floor(100 * c[e + 1]);
							void 0 !== c[e + 1]
								? t >= s && t < i - (i - s) / 2
									? (a = e)
									: t >= s && t < i && (a = e + 1)
								: t >= s && (a = e);
						}
					if (n.initialized && a !== p) {
						if (
							!n.allowSlideNext &&
							(u
								? v > n.translate && v > n.minTranslate()
								: v < n.translate && v < n.minTranslate())
						)
							return !1;
						if (
							!n.allowSlidePrev &&
							v > n.translate &&
							v > n.maxTranslate() &&
							(p || 0) !== a
						)
							return !1;
					}
					let b;
					a !== (d || 0) && s && n.emit("beforeSlideChangeStart"),
						n.updateProgress(v),
						(b = a > p ? "next" : a < p ? "prev" : "reset");
					const y = n.virtual && n.params.virtual.enabled;
					if (
						!(y && r) &&
						((u && -v === n.translate) || (!u && v === n.translate))
					)
						return (
							n.updateActiveIndex(a),
							o.autoHeight && n.updateAutoHeight(),
							n.updateSlidesClasses(),
							"slide" !== o.effect && n.setTranslate(v),
							"reset" !== b && (n.transitionStart(s, b), n.transitionEnd(s, b)),
							!1
						);
					if (o.cssMode) {
						const e = n.isHorizontal(),
							s = u ? v : -v;
						if (0 === t)
							y &&
								((n.wrapperEl.style.scrollSnapType = "none"),
								(n._immediateVirtual = !0)),
								y && !n._cssModeVirtualInitialSet && n.params.initialSlide > 0
									? ((n._cssModeVirtualInitialSet = !0),
									  requestAnimationFrame(() => {
											h[e ? "scrollLeft" : "scrollTop"] = s;
									  }))
									: (h[e ? "scrollLeft" : "scrollTop"] = s),
								y &&
									requestAnimationFrame(() => {
										(n.wrapperEl.style.scrollSnapType = ""),
											(n._immediateVirtual = !1);
									});
						else {
							if (!n.support.smoothScroll)
								return (
									C({ swiper: n, targetPosition: s, side: e ? "left" : "top" }),
									!0
								);
							h.scrollTo({ [e ? "left" : "top"]: s, behavior: "smooth" });
						}
						return !0;
					}
					const w = q().isSafari;
					return (
						y && !r && w && n.isElement && n.virtual.update(!1, !1, a),
						n.setTransition(t),
						n.setTranslate(v),
						n.updateActiveIndex(a),
						n.updateSlidesClasses(),
						n.emit("beforeTransitionStart", t, i),
						n.transitionStart(s, b),
						0 === t
							? n.transitionEnd(s, b)
							: n.animating ||
							  ((n.animating = !0),
							  n.onSlideToWrapperTransitionEnd ||
									(n.onSlideToWrapperTransitionEnd = function (e) {
										n &&
											!n.destroyed &&
											e.target === this &&
											(n.wrapperEl.removeEventListener(
												"transitionend",
												n.onSlideToWrapperTransitionEnd,
											),
											(n.onSlideToWrapperTransitionEnd = null),
											delete n.onSlideToWrapperTransitionEnd,
											n.transitionEnd(s, b));
									}),
							  n.wrapperEl.addEventListener(
									"transitionend",
									n.onSlideToWrapperTransitionEnd,
							  )),
						!0
					);
				},
				slideToLoop: function (e, t, s, i) {
					if (
						(void 0 === e && (e = 0),
						void 0 === s && (s = !0),
						"string" == typeof e)
					) {
						e = parseInt(e, 10);
					}
					const r = this;
					if (r.destroyed) return;
					void 0 === t && (t = r.params.speed);
					const n = r.grid && r.params.grid && r.params.grid.rows > 1;
					let a = e;
					if (r.params.loop)
						if (r.virtual && r.params.virtual.enabled)
							a += r.virtual.slidesBefore;
						else {
							let e;
							if (n) {
								const t = a * r.params.grid.rows;
								e = r.slides.find(
									(e) => 1 * e.getAttribute("data-swiper-slide-index") === t,
								).column;
							} else e = r.getSlideIndexByData(a);
							const t = n
									? Math.ceil(r.slides.length / r.params.grid.rows)
									: r.slides.length,
								{ centeredSlides: s } = r.params;
							let o = r.params.slidesPerView;
							"auto" === o
								? (o = r.slidesPerViewDynamic())
								: ((o = Math.ceil(parseFloat(r.params.slidesPerView, 10))),
								  s && o % 2 == 0 && (o += 1));
							let l = t - e < o;
							if (
								(s && (l = l || e < Math.ceil(o / 2)),
								i && s && "auto" !== r.params.slidesPerView && !n && (l = !1),
								l)
							) {
								const i = s
									? e < r.activeIndex
										? "prev"
										: "next"
									: e - r.activeIndex - 1 < r.params.slidesPerView
									? "next"
									: "prev";
								r.loopFix({
									direction: i,
									slideTo: !0,
									activeSlideIndex: "next" === i ? e + 1 : e - t + 1,
									slideRealIndex: "next" === i ? r.realIndex : void 0,
								});
							}
							if (n) {
								const e = a * r.params.grid.rows;
								a = r.slides.find(
									(t) => 1 * t.getAttribute("data-swiper-slide-index") === e,
								).column;
							} else a = r.getSlideIndexByData(a);
						}
					return (
						requestAnimationFrame(() => {
							r.slideTo(a, t, s, i);
						}),
						r
					);
				},
				slideNext: function (e, t, s) {
					void 0 === t && (t = !0);
					const i = this,
						{ enabled: r, params: n, animating: a } = i;
					if (!r || i.destroyed) return i;
					void 0 === e && (e = i.params.speed);
					let o = n.slidesPerGroup;
					"auto" === n.slidesPerView &&
						1 === n.slidesPerGroup &&
						n.slidesPerGroupAuto &&
						(o = Math.max(i.slidesPerViewDynamic("current", !0), 1));
					const l = i.activeIndex < n.slidesPerGroupSkip ? 1 : o,
						c = i.virtual && n.virtual.enabled;
					if (n.loop) {
						if (a && !c && n.loopPreventsSliding) return !1;
						if (
							(i.loopFix({ direction: "next" }),
							(i._clientLeft = i.wrapperEl.clientLeft),
							i.activeIndex === i.slides.length - 1 && n.cssMode)
						)
							return (
								requestAnimationFrame(() => {
									i.slideTo(i.activeIndex + l, e, t, s);
								}),
								!0
							);
					}
					return n.rewind && i.isEnd
						? i.slideTo(0, e, t, s)
						: i.slideTo(i.activeIndex + l, e, t, s);
				},
				slidePrev: function (e, t, s) {
					void 0 === t && (t = !0);
					const i = this,
						{
							params: r,
							snapGrid: n,
							slidesGrid: a,
							rtlTranslate: o,
							enabled: l,
							animating: c,
						} = i;
					if (!l || i.destroyed) return i;
					void 0 === e && (e = i.params.speed);
					const d = i.virtual && r.virtual.enabled;
					if (r.loop) {
						if (c && !d && r.loopPreventsSliding) return !1;
						i.loopFix({ direction: "prev" }),
							(i._clientLeft = i.wrapperEl.clientLeft);
					}
					function p(e) {
						return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e);
					}
					const u = p(o ? i.translate : -i.translate),
						h = n.map((e) => p(e)),
						m = r.freeMode && r.freeMode.enabled;
					let f = n[h.indexOf(u) - 1];
					if (void 0 === f && (r.cssMode || m)) {
						let e;
						n.forEach((t, s) => {
							u >= t && (e = s);
						}),
							void 0 !== e && (f = m ? n[e] : n[e > 0 ? e - 1 : e]);
					}
					let g = 0;
					if (
						(void 0 !== f &&
							((g = a.indexOf(f)),
							g < 0 && (g = i.activeIndex - 1),
							"auto" === r.slidesPerView &&
								1 === r.slidesPerGroup &&
								r.slidesPerGroupAuto &&
								((g = g - i.slidesPerViewDynamic("previous", !0) + 1),
								(g = Math.max(g, 0)))),
						r.rewind && i.isBeginning)
					) {
						const r =
							i.params.virtual && i.params.virtual.enabled && i.virtual
								? i.virtual.slides.length - 1
								: i.slides.length - 1;
						return i.slideTo(r, e, t, s);
					}
					return r.loop && 0 === i.activeIndex && r.cssMode
						? (requestAnimationFrame(() => {
								i.slideTo(g, e, t, s);
						  }),
						  !0)
						: i.slideTo(g, e, t, s);
				},
				slideReset: function (e, t, s) {
					void 0 === t && (t = !0);
					const i = this;
					if (!i.destroyed)
						return (
							void 0 === e && (e = i.params.speed),
							i.slideTo(i.activeIndex, e, t, s)
						);
				},
				slideToClosest: function (e, t, s, i) {
					void 0 === t && (t = !0), void 0 === i && (i = 0.5);
					const r = this;
					if (r.destroyed) return;
					void 0 === e && (e = r.params.speed);
					let n = r.activeIndex;
					const a = Math.min(r.params.slidesPerGroupSkip, n),
						o = a + Math.floor((n - a) / r.params.slidesPerGroup),
						l = r.rtlTranslate ? r.translate : -r.translate;
					if (l >= r.snapGrid[o]) {
						const e = r.snapGrid[o];
						l - e > (r.snapGrid[o + 1] - e) * i &&
							(n += r.params.slidesPerGroup);
					} else {
						const e = r.snapGrid[o - 1];
						l - e <= (r.snapGrid[o] - e) * i && (n -= r.params.slidesPerGroup);
					}
					return (
						(n = Math.max(n, 0)),
						(n = Math.min(n, r.slidesGrid.length - 1)),
						r.slideTo(n, e, t, s)
					);
				},
				slideToClickedSlide: function () {
					const e = this;
					if (e.destroyed) return;
					const { params: t, slidesEl: s } = e,
						i =
							"auto" === t.slidesPerView
								? e.slidesPerViewDynamic()
								: t.slidesPerView;
					let r,
						n = e.clickedIndex;
					const a = e.isElement ? "swiper-slide" : `.${t.slideClass}`;
					if (t.loop) {
						if (e.animating) return;
						(r = parseInt(
							e.clickedSlide.getAttribute("data-swiper-slide-index"),
							10,
						)),
							t.centeredSlides
								? n < e.loopedSlides - i / 2 ||
								  n > e.slides.length - e.loopedSlides + i / 2
									? (e.loopFix(),
									  (n = e.getSlideIndex(
											O(s, `${a}[data-swiper-slide-index="${r}"]`)[0],
									  )),
									  w(() => {
											e.slideTo(n);
									  }))
									: e.slideTo(n)
								: n > e.slides.length - i
								? (e.loopFix(),
								  (n = e.getSlideIndex(
										O(s, `${a}[data-swiper-slide-index="${r}"]`)[0],
								  )),
								  w(() => {
										e.slideTo(n);
								  }))
								: e.slideTo(n);
					} else e.slideTo(n);
				},
			};
			var Z = {
				loopCreate: function (e, t) {
					const s = this,
						{ params: i, slidesEl: r } = s;
					if (!i.loop || (s.virtual && s.params.virtual.enabled)) return;
					const n = () => {
							O(r, `.${i.slideClass}, swiper-slide`).forEach((e, t) => {
								e.setAttribute("data-swiper-slide-index", t);
							});
						},
						a = s.grid && i.grid && i.grid.rows > 1,
						o = i.slidesPerGroup * (a ? i.grid.rows : 1),
						l = s.slides.length % o != 0,
						c = a && s.slides.length % i.grid.rows != 0,
						d = (e) => {
							for (let t = 0; t < e; t += 1) {
								const e = s.isElement
									? M("swiper-slide", [i.slideBlankClass])
									: M("div", [i.slideClass, i.slideBlankClass]);
								s.slidesEl.append(e);
							}
						};
					if (l) {
						if (i.loopAddBlankSlides) {
							d(o - (s.slides.length % o)), s.recalcSlides(), s.updateSlides();
						} else
							A(
								"Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)",
							);
						n();
					} else if (c) {
						if (i.loopAddBlankSlides) {
							d(i.grid.rows - (s.slides.length % i.grid.rows)),
								s.recalcSlides(),
								s.updateSlides();
						} else
							A(
								"Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)",
							);
						n();
					} else n();
					s.loopFix({
						slideRealIndex: e,
						direction: i.centeredSlides ? void 0 : "next",
						initial: t,
					});
				},
				loopFix: function (e) {
					let {
						slideRealIndex: t,
						slideTo: s = !0,
						direction: i,
						setTranslate: r,
						activeSlideIndex: n,
						initial: a,
						byController: o,
						byMousewheel: l,
					} = void 0 === e ? {} : e;
					const c = this;
					if (!c.params.loop) return;
					c.emit("beforeLoopFix");
					const {
							slides: d,
							allowSlidePrev: p,
							allowSlideNext: u,
							slidesEl: h,
							params: m,
						} = c,
						{ centeredSlides: f, initialSlide: g } = m;
					if (
						((c.allowSlidePrev = !0),
						(c.allowSlideNext = !0),
						c.virtual && m.virtual.enabled)
					)
						return (
							s &&
								(m.centeredSlides || 0 !== c.snapIndex
									? m.centeredSlides && c.snapIndex < m.slidesPerView
										? c.slideTo(
												c.virtual.slides.length + c.snapIndex,
												0,
												!1,
												!0,
										  )
										: c.snapIndex === c.snapGrid.length - 1 &&
										  c.slideTo(c.virtual.slidesBefore, 0, !1, !0)
									: c.slideTo(c.virtual.slides.length, 0, !1, !0)),
							(c.allowSlidePrev = p),
							(c.allowSlideNext = u),
							void c.emit("loopFix")
						);
					let v = m.slidesPerView;
					"auto" === v
						? (v = c.slidesPerViewDynamic())
						: ((v = Math.ceil(parseFloat(m.slidesPerView, 10))),
						  f && v % 2 == 0 && (v += 1));
					const b = m.slidesPerGroupAuto ? v : m.slidesPerGroup;
					let y = b;
					y % b != 0 && (y += b - (y % b)),
						(y += m.loopAdditionalSlides),
						(c.loopedSlides = y);
					const w = c.grid && m.grid && m.grid.rows > 1;
					d.length < v + y ||
					("cards" === c.params.effect && d.length < v + 2 * y)
						? A(
								"Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled or not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters",
						  )
						: w &&
						  "row" === m.grid.fill &&
						  A(
								"Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`",
						  );
					const E = [],
						S = [],
						x = w ? Math.ceil(d.length / m.grid.rows) : d.length,
						T = a && x - g < v && !f;
					let L = T ? g : c.activeIndex;
					void 0 === n
						? (n = c.getSlideIndex(
								d.find((e) => e.classList.contains(m.slideActiveClass)),
						  ))
						: (L = n);
					const C = "next" === i || !i,
						O = "prev" === i || !i;
					let M = 0,
						k = 0;
					const _ =
						(w ? d[n].column : n) + (f && void 0 === r ? -v / 2 + 0.5 : 0);
					if (_ < y) {
						M = Math.max(y - _, b);
						for (let e = 0; e < y - _; e += 1) {
							const t = e - Math.floor(e / x) * x;
							if (w) {
								const e = x - t - 1;
								for (let t = d.length - 1; t >= 0; t -= 1)
									d[t].column === e && E.push(t);
							} else E.push(x - t - 1);
						}
					} else if (_ + v > x - y) {
						(k = Math.max(_ - (x - 2 * y), b)),
							T && (k = Math.max(k, v - x + g + 1));
						for (let e = 0; e < k; e += 1) {
							const t = e - Math.floor(e / x) * x;
							w
								? d.forEach((e, s) => {
										e.column === t && S.push(s);
								  })
								: S.push(t);
						}
					}
					if (
						((c.__preventObserver__ = !0),
						requestAnimationFrame(() => {
							c.__preventObserver__ = !1;
						}),
						"cards" === c.params.effect &&
							d.length < v + 2 * y &&
							(S.includes(n) && S.splice(S.indexOf(n), 1),
							E.includes(n) && E.splice(E.indexOf(n), 1)),
						O &&
							E.forEach((e) => {
								(d[e].swiperLoopMoveDOM = !0),
									h.prepend(d[e]),
									(d[e].swiperLoopMoveDOM = !1);
							}),
						C &&
							S.forEach((e) => {
								(d[e].swiperLoopMoveDOM = !0),
									h.append(d[e]),
									(d[e].swiperLoopMoveDOM = !1);
							}),
						c.recalcSlides(),
						"auto" === m.slidesPerView
							? c.updateSlides()
							: w &&
							  ((E.length > 0 && O) || (S.length > 0 && C)) &&
							  c.slides.forEach((e, t) => {
									c.grid.updateSlide(t, e, c.slides);
							  }),
						m.watchSlidesProgress && c.updateSlidesOffset(),
						s)
					)
						if (E.length > 0 && O) {
							if (void 0 === t) {
								const e = c.slidesGrid[L],
									t = c.slidesGrid[L + M] - e;
								l
									? c.setTranslate(c.translate - t)
									: (c.slideTo(L + Math.ceil(M), 0, !1, !0),
									  r &&
											((c.touchEventsData.startTranslate =
												c.touchEventsData.startTranslate - t),
											(c.touchEventsData.currentTranslate =
												c.touchEventsData.currentTranslate - t)));
							} else if (r) {
								const e = w ? E.length / m.grid.rows : E.length;
								c.slideTo(c.activeIndex + e, 0, !1, !0),
									(c.touchEventsData.currentTranslate = c.translate);
							}
						} else if (S.length > 0 && C)
							if (void 0 === t) {
								const e = c.slidesGrid[L],
									t = c.slidesGrid[L - k] - e;
								l
									? c.setTranslate(c.translate - t)
									: (c.slideTo(L - k, 0, !1, !0),
									  r &&
											((c.touchEventsData.startTranslate =
												c.touchEventsData.startTranslate - t),
											(c.touchEventsData.currentTranslate =
												c.touchEventsData.currentTranslate - t)));
							} else {
								const e = w ? S.length / m.grid.rows : S.length;
								c.slideTo(c.activeIndex - e, 0, !1, !0);
							}
					if (
						((c.allowSlidePrev = p),
						(c.allowSlideNext = u),
						c.controller && c.controller.control && !o)
					) {
						const e = {
							slideRealIndex: t,
							direction: i,
							setTranslate: r,
							activeSlideIndex: n,
							byController: !0,
						};
						Array.isArray(c.controller.control)
							? c.controller.control.forEach((t) => {
									!t.destroyed &&
										t.params.loop &&
										t.loopFix({
											...e,
											slideTo: t.params.slidesPerView === m.slidesPerView && s,
										});
							  })
							: c.controller.control instanceof c.constructor &&
							  c.controller.control.params.loop &&
							  c.controller.control.loopFix({
									...e,
									slideTo:
										c.controller.control.params.slidesPerView ===
											m.slidesPerView && s,
							  });
					}
					c.emit("loopFix");
				},
				loopDestroy: function () {
					const e = this,
						{ params: t, slidesEl: s } = e;
					if (!t.loop || !s || (e.virtual && e.params.virtual.enabled)) return;
					e.recalcSlides();
					const i = [];
					e.slides.forEach((e) => {
						const t =
							void 0 === e.swiperSlideIndex
								? 1 * e.getAttribute("data-swiper-slide-index")
								: e.swiperSlideIndex;
						i[t] = e;
					}),
						e.slides.forEach((e) => {
							e.removeAttribute("data-swiper-slide-index");
						}),
						i.forEach((e) => {
							s.append(e);
						}),
						e.recalcSlides(),
						e.slideTo(e.realIndex, 0);
				},
			};
			function Q(e, t, s) {
				const i = b(),
					{ params: r } = e,
					n = r.edgeSwipeDetection,
					a = r.edgeSwipeThreshold;
				return (
					!n ||
					!(s <= a || s >= i.innerWidth - a) ||
					("prevent" === n && (t.preventDefault(), !0))
				);
			}
			function J(e) {
				const t = this,
					s = g();
				let i = e;
				i.originalEvent && (i = i.originalEvent);
				const r = t.touchEventsData;
				if ("pointerdown" === i.type) {
					if (null !== r.pointerId && r.pointerId !== i.pointerId) return;
					r.pointerId = i.pointerId;
				} else
					"touchstart" === i.type &&
						1 === i.targetTouches.length &&
						(r.touchId = i.targetTouches[0].identifier);
				if ("touchstart" === i.type)
					return void Q(t, i, i.targetTouches[0].pageX);
				const { params: n, touches: a, enabled: o } = t;
				if (!o) return;
				if (!n.simulateTouch && "mouse" === i.pointerType) return;
				if (t.animating && n.preventInteractionOnTransition) return;
				!t.animating && n.cssMode && n.loop && t.loopFix();
				let l = i.target;
				if (
					"wrapper" === n.touchEventsTarget &&
					!(function (e, t) {
						const s = b();
						let i = t.contains(e);
						!i &&
							s.HTMLSlotElement &&
							t instanceof HTMLSlotElement &&
							((i = [...t.assignedElements()].includes(e)),
							i ||
								(i = (function (e, t) {
									const s = [t];
									for (; s.length > 0; ) {
										const t = s.shift();
										if (e === t) return !0;
										s.push(
											...t.children,
											...(t.shadowRoot ? t.shadowRoot.children : []),
											...(t.assignedElements ? t.assignedElements() : []),
										);
									}
								})(e, t)));
						return i;
					})(l, t.wrapperEl)
				)
					return;
				if ("which" in i && 3 === i.which) return;
				if ("button" in i && i.button > 0) return;
				if (r.isTouched && r.isMoved) return;
				const c = !!n.noSwipingClass && "" !== n.noSwipingClass,
					d = i.composedPath ? i.composedPath() : i.path;
				c && i.target && i.target.shadowRoot && d && (l = d[0]);
				const p = n.noSwipingSelector
						? n.noSwipingSelector
						: `.${n.noSwipingClass}`,
					u = !(!i.target || !i.target.shadowRoot);
				if (
					n.noSwiping &&
					(u
						? (function (e, t) {
								return (
									void 0 === t && (t = this),
									(function t(s) {
										if (!s || s === g() || s === b()) return null;
										s.assignedSlot && (s = s.assignedSlot);
										const i = s.closest(e);
										return i || s.getRootNode
											? i || t(s.getRootNode().host)
											: null;
									})(t)
								);
						  })(p, l)
						: l.closest(p))
				)
					return void (t.allowClick = !0);
				if (n.swipeHandler && !l.closest(n.swipeHandler)) return;
				(a.currentX = i.pageX), (a.currentY = i.pageY);
				const h = a.currentX,
					m = a.currentY;
				if (!Q(t, i, h)) return;
				Object.assign(r, {
					isTouched: !0,
					isMoved: !1,
					allowTouchCallbacks: !0,
					isScrolling: void 0,
					startMoving: void 0,
				}),
					(a.startX = h),
					(a.startY = m),
					(r.touchStartTime = E()),
					(t.allowClick = !0),
					t.updateSize(),
					(t.swipeDirection = void 0),
					n.threshold > 0 && (r.allowThresholdMove = !1);
				let f = !0;
				l.matches(r.focusableElements) &&
					((f = !1), "SELECT" === l.nodeName && (r.isTouched = !1)),
					s.activeElement &&
						s.activeElement.matches(r.focusableElements) &&
						s.activeElement !== l &&
						("mouse" === i.pointerType ||
							("mouse" !== i.pointerType && !l.matches(r.focusableElements))) &&
						s.activeElement.blur();
				const v = f && t.allowTouchMove && n.touchStartPreventDefault;
				(!n.touchStartForcePreventDefault && !v) ||
					l.isContentEditable ||
					i.preventDefault(),
					n.freeMode &&
						n.freeMode.enabled &&
						t.freeMode &&
						t.animating &&
						!n.cssMode &&
						t.freeMode.onTouchStart(),
					t.emit("touchStart", i);
			}
			function ee(e) {
				const t = g(),
					s = this,
					i = s.touchEventsData,
					{ params: r, touches: n, rtlTranslate: a, enabled: o } = s;
				if (!o) return;
				if (!r.simulateTouch && "mouse" === e.pointerType) return;
				let l,
					c = e;
				if (
					(c.originalEvent && (c = c.originalEvent), "pointermove" === c.type)
				) {
					if (null !== i.touchId) return;
					if (c.pointerId !== i.pointerId) return;
				}
				if ("touchmove" === c.type) {
					if (
						((l = [...c.changedTouches].find(
							(e) => e.identifier === i.touchId,
						)),
						!l || l.identifier !== i.touchId)
					)
						return;
				} else l = c;
				if (!i.isTouched)
					return void (
						i.startMoving &&
						i.isScrolling &&
						s.emit("touchMoveOpposite", c)
					);
				const d = l.pageX,
					p = l.pageY;
				if (c.preventedByNestedSwiper)
					return (n.startX = d), void (n.startY = p);
				if (!s.allowTouchMove)
					return (
						c.target.matches(i.focusableElements) || (s.allowClick = !1),
						void (
							i.isTouched &&
							(Object.assign(n, {
								startX: d,
								startY: p,
								currentX: d,
								currentY: p,
							}),
							(i.touchStartTime = E()))
						)
					);
				if (r.touchReleaseOnEdges && !r.loop)
					if (s.isVertical()) {
						if (
							(p < n.startY && s.translate <= s.maxTranslate()) ||
							(p > n.startY && s.translate >= s.minTranslate())
						)
							return (i.isTouched = !1), void (i.isMoved = !1);
					} else {
						if (
							a &&
							((d > n.startX && -s.translate <= s.maxTranslate()) ||
								(d < n.startX && -s.translate >= s.minTranslate()))
						)
							return;
						if (
							!a &&
							((d < n.startX && s.translate <= s.maxTranslate()) ||
								(d > n.startX && s.translate >= s.minTranslate()))
						)
							return;
					}
				if (
					(t.activeElement &&
						t.activeElement.matches(i.focusableElements) &&
						t.activeElement !== c.target &&
						"mouse" !== c.pointerType &&
						t.activeElement.blur(),
					t.activeElement &&
						c.target === t.activeElement &&
						c.target.matches(i.focusableElements))
				)
					return (i.isMoved = !0), void (s.allowClick = !1);
				i.allowTouchCallbacks && s.emit("touchMove", c),
					(n.previousX = n.currentX),
					(n.previousY = n.currentY),
					(n.currentX = d),
					(n.currentY = p);
				const u = n.currentX - n.startX,
					h = n.currentY - n.startY;
				if (
					s.params.threshold &&
					Math.sqrt(u ** 2 + h ** 2) < s.params.threshold
				)
					return;
				if (void 0 === i.isScrolling) {
					let e;
					(s.isHorizontal() && n.currentY === n.startY) ||
					(s.isVertical() && n.currentX === n.startX)
						? (i.isScrolling = !1)
						: u * u + h * h >= 25 &&
						  ((e = (180 * Math.atan2(Math.abs(h), Math.abs(u))) / Math.PI),
						  (i.isScrolling = s.isHorizontal()
								? e > r.touchAngle
								: 90 - e > r.touchAngle));
				}
				if (
					(i.isScrolling && s.emit("touchMoveOpposite", c),
					void 0 === i.startMoving &&
						((n.currentX === n.startX && n.currentY === n.startY) ||
							(i.startMoving = !0)),
					i.isScrolling ||
						("touchmove" === c.type && i.preventTouchMoveFromPointerMove))
				)
					return void (i.isTouched = !1);
				if (!i.startMoving) return;
				(s.allowClick = !1),
					!r.cssMode && c.cancelable && c.preventDefault(),
					r.touchMoveStopPropagation && !r.nested && c.stopPropagation();
				let m = s.isHorizontal() ? u : h,
					f = s.isHorizontal()
						? n.currentX - n.previousX
						: n.currentY - n.previousY;
				r.oneWayMovement &&
					((m = Math.abs(m) * (a ? 1 : -1)), (f = Math.abs(f) * (a ? 1 : -1))),
					(n.diff = m),
					(m *= r.touchRatio),
					a && ((m = -m), (f = -f));
				const v = s.touchesDirection;
				(s.swipeDirection = m > 0 ? "prev" : "next"),
					(s.touchesDirection = f > 0 ? "prev" : "next");
				const b = s.params.loop && !r.cssMode,
					y =
						("next" === s.touchesDirection && s.allowSlideNext) ||
						("prev" === s.touchesDirection && s.allowSlidePrev);
				if (!i.isMoved) {
					if (
						(b && y && s.loopFix({ direction: s.swipeDirection }),
						(i.startTranslate = s.getTranslate()),
						s.setTransition(0),
						s.animating)
					) {
						const e = new window.CustomEvent("transitionend", {
							bubbles: !0,
							cancelable: !0,
							detail: { bySwiperTouchMove: !0 },
						});
						s.wrapperEl.dispatchEvent(e);
					}
					(i.allowMomentumBounce = !1),
						!r.grabCursor ||
							(!0 !== s.allowSlideNext && !0 !== s.allowSlidePrev) ||
							s.setGrabCursor(!0),
						s.emit("sliderFirstMove", c);
				}
				if (
					(new Date().getTime(),
					!1 !== r._loopSwapReset &&
						i.isMoved &&
						i.allowThresholdMove &&
						v !== s.touchesDirection &&
						b &&
						y &&
						Math.abs(m) >= 1)
				)
					return (
						Object.assign(n, {
							startX: d,
							startY: p,
							currentX: d,
							currentY: p,
							startTranslate: i.currentTranslate,
						}),
						(i.loopSwapReset = !0),
						void (i.startTranslate = i.currentTranslate)
					);
				s.emit("sliderMove", c),
					(i.isMoved = !0),
					(i.currentTranslate = m + i.startTranslate);
				let w = !0,
					S = r.resistanceRatio;
				if (
					(r.touchReleaseOnEdges && (S = 0),
					m > 0
						? (b &&
								y &&
								i.allowThresholdMove &&
								i.currentTranslate >
									(r.centeredSlides
										? s.minTranslate() -
										  s.slidesSizesGrid[s.activeIndex + 1] -
										  ("auto" !== r.slidesPerView &&
										  s.slides.length - r.slidesPerView >= 2
												? s.slidesSizesGrid[s.activeIndex + 1] +
												  s.params.spaceBetween
												: 0) -
										  s.params.spaceBetween
										: s.minTranslate()) &&
								s.loopFix({
									direction: "prev",
									setTranslate: !0,
									activeSlideIndex: 0,
								}),
						  i.currentTranslate > s.minTranslate() &&
								((w = !1),
								r.resistance &&
									(i.currentTranslate =
										s.minTranslate() -
										1 +
										(-s.minTranslate() + i.startTranslate + m) ** S)))
						: m < 0 &&
						  (b &&
								y &&
								i.allowThresholdMove &&
								i.currentTranslate <
									(r.centeredSlides
										? s.maxTranslate() +
										  s.slidesSizesGrid[s.slidesSizesGrid.length - 1] +
										  s.params.spaceBetween +
										  ("auto" !== r.slidesPerView &&
										  s.slides.length - r.slidesPerView >= 2
												? s.slidesSizesGrid[s.slidesSizesGrid.length - 1] +
												  s.params.spaceBetween
												: 0)
										: s.maxTranslate()) &&
								s.loopFix({
									direction: "next",
									setTranslate: !0,
									activeSlideIndex:
										s.slides.length -
										("auto" === r.slidesPerView
											? s.slidesPerViewDynamic()
											: Math.ceil(parseFloat(r.slidesPerView, 10))),
								}),
						  i.currentTranslate < s.maxTranslate() &&
								((w = !1),
								r.resistance &&
									(i.currentTranslate =
										s.maxTranslate() +
										1 -
										(s.maxTranslate() - i.startTranslate - m) ** S))),
					w && (c.preventedByNestedSwiper = !0),
					!s.allowSlideNext &&
						"next" === s.swipeDirection &&
						i.currentTranslate < i.startTranslate &&
						(i.currentTranslate = i.startTranslate),
					!s.allowSlidePrev &&
						"prev" === s.swipeDirection &&
						i.currentTranslate > i.startTranslate &&
						(i.currentTranslate = i.startTranslate),
					s.allowSlidePrev ||
						s.allowSlideNext ||
						(i.currentTranslate = i.startTranslate),
					r.threshold > 0)
				) {
					if (!(Math.abs(m) > r.threshold || i.allowThresholdMove))
						return void (i.currentTranslate = i.startTranslate);
					if (!i.allowThresholdMove)
						return (
							(i.allowThresholdMove = !0),
							(n.startX = n.currentX),
							(n.startY = n.currentY),
							(i.currentTranslate = i.startTranslate),
							void (n.diff = s.isHorizontal()
								? n.currentX - n.startX
								: n.currentY - n.startY)
						);
				}
				r.followFinger &&
					!r.cssMode &&
					(((r.freeMode && r.freeMode.enabled && s.freeMode) ||
						r.watchSlidesProgress) &&
						(s.updateActiveIndex(), s.updateSlidesClasses()),
					r.freeMode &&
						r.freeMode.enabled &&
						s.freeMode &&
						s.freeMode.onTouchMove(),
					s.updateProgress(i.currentTranslate),
					s.setTranslate(i.currentTranslate));
			}
			function te(e) {
				const t = this,
					s = t.touchEventsData;
				let i,
					r = e;
				r.originalEvent && (r = r.originalEvent);
				if ("touchend" === r.type || "touchcancel" === r.type) {
					if (
						((i = [...r.changedTouches].find(
							(e) => e.identifier === s.touchId,
						)),
						!i || i.identifier !== s.touchId)
					)
						return;
				} else {
					if (null !== s.touchId) return;
					if (r.pointerId !== s.pointerId) return;
					i = r;
				}
				if (
					[
						"pointercancel",
						"pointerout",
						"pointerleave",
						"contextmenu",
					].includes(r.type)
				) {
					if (
						!(
							["pointercancel", "contextmenu"].includes(r.type) &&
							(t.browser.isSafari || t.browser.isWebView)
						)
					)
						return;
				}
				(s.pointerId = null), (s.touchId = null);
				const {
					params: n,
					touches: a,
					rtlTranslate: o,
					slidesGrid: l,
					enabled: c,
				} = t;
				if (!c) return;
				if (!n.simulateTouch && "mouse" === r.pointerType) return;
				if (
					(s.allowTouchCallbacks && t.emit("touchEnd", r),
					(s.allowTouchCallbacks = !1),
					!s.isTouched)
				)
					return (
						s.isMoved && n.grabCursor && t.setGrabCursor(!1),
						(s.isMoved = !1),
						void (s.startMoving = !1)
					);
				n.grabCursor &&
					s.isMoved &&
					s.isTouched &&
					(!0 === t.allowSlideNext || !0 === t.allowSlidePrev) &&
					t.setGrabCursor(!1);
				const d = E(),
					p = d - s.touchStartTime;
				if (t.allowClick) {
					const e = r.path || (r.composedPath && r.composedPath());
					t.updateClickedSlide((e && e[0]) || r.target, e),
						t.emit("tap click", r),
						p < 300 &&
							d - s.lastClickTime < 300 &&
							t.emit("doubleTap doubleClick", r);
				}
				if (
					((s.lastClickTime = E()),
					w(() => {
						t.destroyed || (t.allowClick = !0);
					}),
					!s.isTouched ||
						!s.isMoved ||
						!t.swipeDirection ||
						(0 === a.diff && !s.loopSwapReset) ||
						(s.currentTranslate === s.startTranslate && !s.loopSwapReset))
				)
					return (
						(s.isTouched = !1), (s.isMoved = !1), void (s.startMoving = !1)
					);
				let u;
				if (
					((s.isTouched = !1),
					(s.isMoved = !1),
					(s.startMoving = !1),
					(u = n.followFinger
						? o
							? t.translate
							: -t.translate
						: -s.currentTranslate),
					n.cssMode)
				)
					return;
				if (n.freeMode && n.freeMode.enabled)
					return void t.freeMode.onTouchEnd({ currentPos: u });
				const h = u >= -t.maxTranslate() && !t.params.loop;
				let m = 0,
					f = t.slidesSizesGrid[0];
				for (
					let e = 0;
					e < l.length;
					e += e < n.slidesPerGroupSkip ? 1 : n.slidesPerGroup
				) {
					const t = e < n.slidesPerGroupSkip - 1 ? 1 : n.slidesPerGroup;
					void 0 !== l[e + t]
						? (h || (u >= l[e] && u < l[e + t])) &&
						  ((m = e), (f = l[e + t] - l[e]))
						: (h || u >= l[e]) &&
						  ((m = e), (f = l[l.length - 1] - l[l.length - 2]));
				}
				let g = null,
					v = null;
				n.rewind &&
					(t.isBeginning
						? (v =
								n.virtual && n.virtual.enabled && t.virtual
									? t.virtual.slides.length - 1
									: t.slides.length - 1)
						: t.isEnd && (g = 0));
				const b = (u - l[m]) / f,
					y = m < n.slidesPerGroupSkip - 1 ? 1 : n.slidesPerGroup;
				if (p > n.longSwipesMs) {
					if (!n.longSwipes) return void t.slideTo(t.activeIndex);
					"next" === t.swipeDirection &&
						(b >= n.longSwipesRatio
							? t.slideTo(n.rewind && t.isEnd ? g : m + y)
							: t.slideTo(m)),
						"prev" === t.swipeDirection &&
							(b > 1 - n.longSwipesRatio
								? t.slideTo(m + y)
								: null !== v && b < 0 && Math.abs(b) > n.longSwipesRatio
								? t.slideTo(v)
								: t.slideTo(m));
				} else {
					if (!n.shortSwipes) return void t.slideTo(t.activeIndex);
					t.navigation &&
					(r.target === t.navigation.nextEl || r.target === t.navigation.prevEl)
						? r.target === t.navigation.nextEl
							? t.slideTo(m + y)
							: t.slideTo(m)
						: ("next" === t.swipeDirection && t.slideTo(null !== g ? g : m + y),
						  "prev" === t.swipeDirection && t.slideTo(null !== v ? v : m));
				}
			}
			function se() {
				const e = this,
					{ params: t, el: s } = e;
				if (s && 0 === s.offsetWidth) return;
				t.breakpoints && e.setBreakpoint();
				const { allowSlideNext: i, allowSlidePrev: r, snapGrid: n } = e,
					a = e.virtual && e.params.virtual.enabled;
				(e.allowSlideNext = !0),
					(e.allowSlidePrev = !0),
					e.updateSize(),
					e.updateSlides(),
					e.updateSlidesClasses();
				const o = a && t.loop;
				!("auto" === t.slidesPerView || t.slidesPerView > 1) ||
				!e.isEnd ||
				e.isBeginning ||
				e.params.centeredSlides ||
				o
					? e.params.loop && !a
						? e.slideToLoop(e.realIndex, 0, !1, !0)
						: e.slideTo(e.activeIndex, 0, !1, !0)
					: e.slideTo(e.slides.length - 1, 0, !1, !0),
					e.autoplay &&
						e.autoplay.running &&
						e.autoplay.paused &&
						(clearTimeout(e.autoplay.resizeTimeout),
						(e.autoplay.resizeTimeout = setTimeout(() => {
							e.autoplay &&
								e.autoplay.running &&
								e.autoplay.paused &&
								e.autoplay.resume();
						}, 500))),
					(e.allowSlidePrev = r),
					(e.allowSlideNext = i),
					e.params.watchOverflow && n !== e.snapGrid && e.checkOverflow();
			}
			function ie(e) {
				const t = this;
				t.enabled &&
					(t.allowClick ||
						(t.params.preventClicks && e.preventDefault(),
						t.params.preventClicksPropagation &&
							t.animating &&
							(e.stopPropagation(), e.stopImmediatePropagation())));
			}
			function re() {
				const e = this,
					{ wrapperEl: t, rtlTranslate: s, enabled: i } = e;
				if (!i) return;
				let r;
				(e.previousTranslate = e.translate),
					e.isHorizontal()
						? (e.translate = -t.scrollLeft)
						: (e.translate = -t.scrollTop),
					0 === e.translate && (e.translate = 0),
					e.updateActiveIndex(),
					e.updateSlidesClasses();
				const n = e.maxTranslate() - e.minTranslate();
				(r = 0 === n ? 0 : (e.translate - e.minTranslate()) / n),
					r !== e.progress && e.updateProgress(s ? -e.translate : e.translate),
					e.emit("setTranslate", e.translate, !1);
			}
			function ne(e) {
				const t = this;
				F(t, e.target),
					t.params.cssMode ||
						("auto" !== t.params.slidesPerView && !t.params.autoHeight) ||
						t.update();
			}
			function ae() {
				const e = this;
				e.documentTouchHandlerProceeded ||
					((e.documentTouchHandlerProceeded = !0),
					e.params.touchReleaseOnEdges && (e.el.style.touchAction = "auto"));
			}
			const oe = (e, t) => {
				const s = g(),
					{ params: i, el: r, wrapperEl: n, device: a } = e,
					o = !!i.nested,
					l = "on" === t ? "addEventListener" : "removeEventListener",
					c = t;
				r &&
					"string" != typeof r &&
					(s[l]("touchstart", e.onDocumentTouchStart, {
						passive: !1,
						capture: o,
					}),
					r[l]("touchstart", e.onTouchStart, { passive: !1 }),
					r[l]("pointerdown", e.onTouchStart, { passive: !1 }),
					s[l]("touchmove", e.onTouchMove, { passive: !1, capture: o }),
					s[l]("pointermove", e.onTouchMove, { passive: !1, capture: o }),
					s[l]("touchend", e.onTouchEnd, { passive: !0 }),
					s[l]("pointerup", e.onTouchEnd, { passive: !0 }),
					s[l]("pointercancel", e.onTouchEnd, { passive: !0 }),
					s[l]("touchcancel", e.onTouchEnd, { passive: !0 }),
					s[l]("pointerout", e.onTouchEnd, { passive: !0 }),
					s[l]("pointerleave", e.onTouchEnd, { passive: !0 }),
					s[l]("contextmenu", e.onTouchEnd, { passive: !0 }),
					(i.preventClicks || i.preventClicksPropagation) &&
						r[l]("click", e.onClick, !0),
					i.cssMode && n[l]("scroll", e.onScroll),
					i.updateOnWindowResize
						? e[c](
								a.ios || a.android
									? "resize orientationchange observerUpdate"
									: "resize observerUpdate",
								se,
								!0,
						  )
						: e[c]("observerUpdate", se, !0),
					r[l]("load", e.onLoad, { capture: !0 }));
			};
			const le = (e, t) => e.grid && t.grid && t.grid.rows > 1;
			var ce = {
				init: !0,
				direction: "horizontal",
				oneWayMovement: !1,
				swiperElementNodeName: "SWIPER-CONTAINER",
				touchEventsTarget: "wrapper",
				initialSlide: 0,
				speed: 300,
				cssMode: !1,
				updateOnWindowResize: !0,
				resizeObserver: !0,
				nested: !1,
				createElements: !1,
				eventsPrefix: "swiper",
				enabled: !0,
				focusableElements:
					"input, select, option, textarea, button, video, label",
				width: null,
				height: null,
				preventInteractionOnTransition: !1,
				userAgent: null,
				url: null,
				edgeSwipeDetection: !1,
				edgeSwipeThreshold: 20,
				autoHeight: !1,
				setWrapperSize: !1,
				virtualTranslate: !1,
				effect: "slide",
				breakpoints: void 0,
				breakpointsBase: "window",
				spaceBetween: 0,
				slidesPerView: 1,
				slidesPerGroup: 1,
				slidesPerGroupSkip: 0,
				slidesPerGroupAuto: !1,
				centeredSlides: !1,
				centeredSlidesBounds: !1,
				slidesOffsetBefore: 0,
				slidesOffsetAfter: 0,
				normalizeSlideIndex: !0,
				centerInsufficientSlides: !1,
				watchOverflow: !0,
				roundLengths: !1,
				touchRatio: 1,
				touchAngle: 45,
				simulateTouch: !0,
				shortSwipes: !0,
				longSwipes: !0,
				longSwipesRatio: 0.5,
				longSwipesMs: 300,
				followFinger: !0,
				allowTouchMove: !0,
				threshold: 5,
				touchMoveStopPropagation: !1,
				touchStartPreventDefault: !0,
				touchStartForcePreventDefault: !1,
				touchReleaseOnEdges: !1,
				uniqueNavElements: !0,
				resistance: !0,
				resistanceRatio: 0.85,
				watchSlidesProgress: !1,
				grabCursor: !1,
				preventClicks: !0,
				preventClicksPropagation: !0,
				slideToClickedSlide: !1,
				loop: !1,
				loopAddBlankSlides: !0,
				loopAdditionalSlides: 0,
				loopPreventsSliding: !0,
				rewind: !1,
				allowSlidePrev: !0,
				allowSlideNext: !0,
				swipeHandler: null,
				noSwiping: !0,
				noSwipingClass: "swiper-no-swiping",
				noSwipingSelector: null,
				passiveListeners: !0,
				maxBackfaceHiddenSlides: 10,
				containerModifierClass: "swiper-",
				slideClass: "swiper-slide",
				slideBlankClass: "swiper-slide-blank",
				slideActiveClass: "swiper-slide-active",
				slideVisibleClass: "swiper-slide-visible",
				slideFullyVisibleClass: "swiper-slide-fully-visible",
				slideNextClass: "swiper-slide-next",
				slidePrevClass: "swiper-slide-prev",
				wrapperClass: "swiper-wrapper",
				lazyPreloaderClass: "swiper-lazy-preloader",
				lazyPreloadPrevNext: 0,
				runCallbacksOnInit: !0,
				_emitClasses: !1,
			};
			function de(e, t) {
				return function (s) {
					void 0 === s && (s = {});
					const i = Object.keys(s)[0],
						r = s[i];
					"object" == typeof r && null !== r
						? (!0 === e[i] && (e[i] = { enabled: !0 }),
						  "navigation" === i &&
								e[i] &&
								e[i].enabled &&
								!e[i].prevEl &&
								!e[i].nextEl &&
								(e[i].auto = !0),
						  ["pagination", "scrollbar"].indexOf(i) >= 0 &&
								e[i] &&
								e[i].enabled &&
								!e[i].el &&
								(e[i].auto = !0),
						  i in e && "enabled" in r
								? ("object" != typeof e[i] ||
										"enabled" in e[i] ||
										(e[i].enabled = !0),
								  e[i] || (e[i] = { enabled: !1 }),
								  T(t, s))
								: T(t, s))
						: T(t, s);
				};
			}
			const pe = {
					eventsEmitter: H,
					update: Y,
					translate: X,
					transition: {
						setTransition: function (e, t) {
							const s = this;
							s.params.cssMode ||
								((s.wrapperEl.style.transitionDuration = `${e}ms`),
								(s.wrapperEl.style.transitionDelay = 0 === e ? "0ms" : "")),
								s.emit("setTransition", e, t);
						},
						transitionStart: function (e, t) {
							void 0 === e && (e = !0);
							const s = this,
								{ params: i } = s;
							i.cssMode ||
								(i.autoHeight && s.updateAutoHeight(),
								U({ swiper: s, runCallbacks: e, direction: t, step: "Start" }));
						},
						transitionEnd: function (e, t) {
							void 0 === e && (e = !0);
							const s = this,
								{ params: i } = s;
							(s.animating = !1),
								i.cssMode ||
									(s.setTransition(0),
									U({ swiper: s, runCallbacks: e, direction: t, step: "End" }));
						},
					},
					slide: K,
					loop: Z,
					grabCursor: {
						setGrabCursor: function (e) {
							const t = this;
							if (
								!t.params.simulateTouch ||
								(t.params.watchOverflow && t.isLocked) ||
								t.params.cssMode
							)
								return;
							const s =
								"container" === t.params.touchEventsTarget ? t.el : t.wrapperEl;
							t.isElement && (t.__preventObserver__ = !0),
								(s.style.cursor = "move"),
								(s.style.cursor = e ? "grabbing" : "grab"),
								t.isElement &&
									requestAnimationFrame(() => {
										t.__preventObserver__ = !1;
									});
						},
						unsetGrabCursor: function () {
							const e = this;
							(e.params.watchOverflow && e.isLocked) ||
								e.params.cssMode ||
								(e.isElement && (e.__preventObserver__ = !0),
								(e[
									"container" === e.params.touchEventsTarget
										? "el"
										: "wrapperEl"
								].style.cursor = ""),
								e.isElement &&
									requestAnimationFrame(() => {
										e.__preventObserver__ = !1;
									}));
						},
					},
					events: {
						attachEvents: function () {
							const e = this,
								{ params: t } = e;
							(e.onTouchStart = J.bind(e)),
								(e.onTouchMove = ee.bind(e)),
								(e.onTouchEnd = te.bind(e)),
								(e.onDocumentTouchStart = ae.bind(e)),
								t.cssMode && (e.onScroll = re.bind(e)),
								(e.onClick = ie.bind(e)),
								(e.onLoad = ne.bind(e)),
								oe(e, "on");
						},
						detachEvents: function () {
							oe(this, "off");
						},
					},
					breakpoints: {
						setBreakpoint: function () {
							const e = this,
								{ realIndex: t, initialized: s, params: i, el: r } = e,
								n = i.breakpoints;
							if (!n || (n && 0 === Object.keys(n).length)) return;
							const a = g(),
								o =
									"window" !== i.breakpointsBase && i.breakpointsBase
										? "container"
										: i.breakpointsBase,
								l =
									["window", "container"].includes(i.breakpointsBase) ||
									!i.breakpointsBase
										? e.el
										: a.querySelector(i.breakpointsBase),
								c = e.getBreakpoint(n, o, l);
							if (!c || e.currentBreakpoint === c) return;
							const d = (c in n ? n[c] : void 0) || e.originalParams,
								p = le(e, i),
								u = le(e, d),
								h = e.params.grabCursor,
								m = d.grabCursor,
								f = i.enabled;
							p && !u
								? (r.classList.remove(
										`${i.containerModifierClass}grid`,
										`${i.containerModifierClass}grid-column`,
								  ),
								  e.emitContainerClasses())
								: !p &&
								  u &&
								  (r.classList.add(`${i.containerModifierClass}grid`),
								  ((d.grid.fill && "column" === d.grid.fill) ||
										(!d.grid.fill && "column" === i.grid.fill)) &&
										r.classList.add(`${i.containerModifierClass}grid-column`),
								  e.emitContainerClasses()),
								h && !m ? e.unsetGrabCursor() : !h && m && e.setGrabCursor(),
								["navigation", "pagination", "scrollbar"].forEach((t) => {
									if (void 0 === d[t]) return;
									const s = i[t] && i[t].enabled,
										r = d[t] && d[t].enabled;
									s && !r && e[t].disable(), !s && r && e[t].enable();
								});
							const v = d.direction && d.direction !== i.direction,
								b = i.loop && (d.slidesPerView !== i.slidesPerView || v),
								y = i.loop;
							v && s && e.changeDirection(), T(e.params, d);
							const w = e.params.enabled,
								E = e.params.loop;
							Object.assign(e, {
								allowTouchMove: e.params.allowTouchMove,
								allowSlideNext: e.params.allowSlideNext,
								allowSlidePrev: e.params.allowSlidePrev,
							}),
								f && !w ? e.disable() : !f && w && e.enable(),
								(e.currentBreakpoint = c),
								e.emit("_beforeBreakpoint", d),
								s &&
									(b
										? (e.loopDestroy(), e.loopCreate(t), e.updateSlides())
										: !y && E
										? (e.loopCreate(t), e.updateSlides())
										: y && !E && e.loopDestroy()),
								e.emit("breakpoint", d);
						},
						getBreakpoint: function (e, t, s) {
							if (
								(void 0 === t && (t = "window"),
								!e || ("container" === t && !s))
							)
								return;
							let i = !1;
							const r = b(),
								n = "window" === t ? r.innerHeight : s.clientHeight,
								a = Object.keys(e).map((e) => {
									if ("string" == typeof e && 0 === e.indexOf("@")) {
										const t = parseFloat(e.substr(1));
										return { value: n * t, point: e };
									}
									return { value: e, point: e };
								});
							a.sort((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10));
							for (let e = 0; e < a.length; e += 1) {
								const { point: n, value: o } = a[e];
								"window" === t
									? r.matchMedia(`(min-width: ${o}px)`).matches && (i = n)
									: o <= s.clientWidth && (i = n);
							}
							return i || "max";
						},
					},
					checkOverflow: {
						checkOverflow: function () {
							const e = this,
								{ isLocked: t, params: s } = e,
								{ slidesOffsetBefore: i } = s;
							if (i) {
								const t = e.slides.length - 1,
									s = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * i;
								e.isLocked = e.size > s;
							} else e.isLocked = 1 === e.snapGrid.length;
							!0 === s.allowSlideNext && (e.allowSlideNext = !e.isLocked),
								!0 === s.allowSlidePrev && (e.allowSlidePrev = !e.isLocked),
								t && t !== e.isLocked && (e.isEnd = !1),
								t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock");
						},
					},
					classes: {
						addClasses: function () {
							const e = this,
								{ classNames: t, params: s, rtl: i, el: r, device: n } = e,
								a = (function (e, t) {
									const s = [];
									return (
										e.forEach((e) => {
											"object" == typeof e
												? Object.keys(e).forEach((i) => {
														e[i] && s.push(t + i);
												  })
												: "string" == typeof e && s.push(t + e);
										}),
										s
									);
								})(
									[
										"initialized",
										s.direction,
										{ "free-mode": e.params.freeMode && s.freeMode.enabled },
										{ autoheight: s.autoHeight },
										{ rtl: i },
										{ grid: s.grid && s.grid.rows > 1 },
										{
											"grid-column":
												s.grid && s.grid.rows > 1 && "column" === s.grid.fill,
										},
										{ android: n.android },
										{ ios: n.ios },
										{ "css-mode": s.cssMode },
										{ centered: s.cssMode && s.centeredSlides },
										{ "watch-progress": s.watchSlidesProgress },
									],
									s.containerModifierClass,
								);
							t.push(...a), r.classList.add(...t), e.emitContainerClasses();
						},
						removeClasses: function () {
							const { el: e, classNames: t } = this;
							e &&
								"string" != typeof e &&
								(e.classList.remove(...t), this.emitContainerClasses());
						},
					},
				},
				ue = {};
			class he {
				constructor() {
					let e, t;
					for (var s = arguments.length, i = new Array(s), r = 0; r < s; r++)
						i[r] = arguments[r];
					1 === i.length &&
					i[0].constructor &&
					"Object" === Object.prototype.toString.call(i[0]).slice(8, -1)
						? (t = i[0])
						: ([e, t] = i),
						t || (t = {}),
						(t = T({}, t)),
						e && !t.el && (t.el = e);
					const n = g();
					if (
						t.el &&
						"string" == typeof t.el &&
						n.querySelectorAll(t.el).length > 1
					) {
						const e = [];
						return (
							n.querySelectorAll(t.el).forEach((s) => {
								const i = T({}, t, { el: s });
								e.push(new he(i));
							}),
							e
						);
					}
					const a = this;
					(a.__swiper__ = !0),
						(a.support = W()),
						(a.device = N({ userAgent: t.userAgent })),
						(a.browser = q()),
						(a.eventsListeners = {}),
						(a.eventsAnyListeners = []),
						(a.modules = [...a.__modules__]),
						t.modules &&
							Array.isArray(t.modules) &&
							a.modules.push(...t.modules);
					const o = {};
					a.modules.forEach((e) => {
						e({
							params: t,
							swiper: a,
							extendParams: de(t, o),
							on: a.on.bind(a),
							once: a.once.bind(a),
							off: a.off.bind(a),
							emit: a.emit.bind(a),
						});
					});
					const l = T({}, ce, o);
					return (
						(a.params = T({}, l, ue, t)),
						(a.originalParams = T({}, a.params)),
						(a.passedParams = T({}, t)),
						a.params &&
							a.params.on &&
							Object.keys(a.params.on).forEach((e) => {
								a.on(e, a.params.on[e]);
							}),
						a.params && a.params.onAny && a.onAny(a.params.onAny),
						Object.assign(a, {
							enabled: a.params.enabled,
							el: e,
							classNames: [],
							slides: [],
							slidesGrid: [],
							snapGrid: [],
							slidesSizesGrid: [],
							isHorizontal: () => "horizontal" === a.params.direction,
							isVertical: () => "vertical" === a.params.direction,
							activeIndex: 0,
							realIndex: 0,
							isBeginning: !0,
							isEnd: !1,
							translate: 0,
							previousTranslate: 0,
							progress: 0,
							velocity: 0,
							animating: !1,
							cssOverflowAdjustment() {
								return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
							},
							allowSlideNext: a.params.allowSlideNext,
							allowSlidePrev: a.params.allowSlidePrev,
							touchEventsData: {
								isTouched: void 0,
								isMoved: void 0,
								allowTouchCallbacks: void 0,
								touchStartTime: void 0,
								isScrolling: void 0,
								currentTranslate: void 0,
								startTranslate: void 0,
								allowThresholdMove: void 0,
								focusableElements: a.params.focusableElements,
								lastClickTime: 0,
								clickTimeout: void 0,
								velocities: [],
								allowMomentumBounce: void 0,
								startMoving: void 0,
								pointerId: null,
								touchId: null,
							},
							allowClick: !0,
							allowTouchMove: a.params.allowTouchMove,
							touches: {
								startX: 0,
								startY: 0,
								currentX: 0,
								currentY: 0,
								diff: 0,
							},
							imagesToLoad: [],
							imagesLoaded: 0,
						}),
						a.emit("_swiper"),
						a.params.init && a.init(),
						a
					);
				}
				getDirectionLabel(e) {
					return this.isHorizontal()
						? e
						: {
								width: "height",
								"margin-top": "margin-left",
								"margin-bottom ": "margin-right",
								"margin-left": "margin-top",
								"margin-right": "margin-bottom",
								"padding-left": "padding-top",
								"padding-right": "padding-bottom",
								marginRight: "marginBottom",
						  }[e];
				}
				getSlideIndex(e) {
					const { slidesEl: t, params: s } = this,
						i = _(O(t, `.${s.slideClass}, swiper-slide`)[0]);
					return _(e) - i;
				}
				getSlideIndexByData(e) {
					return this.getSlideIndex(
						this.slides.find(
							(t) => 1 * t.getAttribute("data-swiper-slide-index") === e,
						),
					);
				}
				recalcSlides() {
					const { slidesEl: e, params: t } = this;
					this.slides = O(e, `.${t.slideClass}, swiper-slide`);
				}
				enable() {
					const e = this;
					e.enabled ||
						((e.enabled = !0),
						e.params.grabCursor && e.setGrabCursor(),
						e.emit("enable"));
				}
				disable() {
					const e = this;
					e.enabled &&
						((e.enabled = !1),
						e.params.grabCursor && e.unsetGrabCursor(),
						e.emit("disable"));
				}
				setProgress(e, t) {
					const s = this;
					e = Math.min(Math.max(e, 0), 1);
					const i = s.minTranslate(),
						r = (s.maxTranslate() - i) * e + i;
					s.translateTo(r, void 0 === t ? 0 : t),
						s.updateActiveIndex(),
						s.updateSlidesClasses();
				}
				emitContainerClasses() {
					const e = this;
					if (!e.params._emitClasses || !e.el) return;
					const t = e.el.className
						.split(" ")
						.filter(
							(t) =>
								0 === t.indexOf("swiper") ||
								0 === t.indexOf(e.params.containerModifierClass),
						);
					e.emit("_containerClasses", t.join(" "));
				}
				getSlideClasses(e) {
					const t = this;
					return t.destroyed
						? ""
						: e.className
								.split(" ")
								.filter(
									(e) =>
										0 === e.indexOf("swiper-slide") ||
										0 === e.indexOf(t.params.slideClass),
								)
								.join(" ");
				}
				emitSlidesClasses() {
					const e = this;
					if (!e.params._emitClasses || !e.el) return;
					const t = [];
					e.slides.forEach((s) => {
						const i = e.getSlideClasses(s);
						t.push({ slideEl: s, classNames: i }), e.emit("_slideClass", s, i);
					}),
						e.emit("_slideClasses", t);
				}
				slidesPerViewDynamic(e, t) {
					void 0 === e && (e = "current"), void 0 === t && (t = !1);
					const {
						params: s,
						slides: i,
						slidesGrid: r,
						slidesSizesGrid: n,
						size: a,
						activeIndex: o,
					} = this;
					let l = 1;
					if ("number" == typeof s.slidesPerView) return s.slidesPerView;
					if (s.centeredSlides) {
						let e,
							t = i[o] ? Math.ceil(i[o].swiperSlideSize) : 0;
						for (let s = o + 1; s < i.length; s += 1)
							i[s] &&
								!e &&
								((t += Math.ceil(i[s].swiperSlideSize)),
								(l += 1),
								t > a && (e = !0));
						for (let s = o - 1; s >= 0; s -= 1)
							i[s] &&
								!e &&
								((t += i[s].swiperSlideSize), (l += 1), t > a && (e = !0));
					} else if ("current" === e)
						for (let e = o + 1; e < i.length; e += 1) {
							(t ? r[e] + n[e] - r[o] < a : r[e] - r[o] < a) && (l += 1);
						}
					else
						for (let e = o - 1; e >= 0; e -= 1) {
							r[o] - r[e] < a && (l += 1);
						}
					return l;
				}
				update() {
					const e = this;
					if (!e || e.destroyed) return;
					const { snapGrid: t, params: s } = e;
					function i() {
						const t = e.rtlTranslate ? -1 * e.translate : e.translate,
							s = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());
						e.setTranslate(s), e.updateActiveIndex(), e.updateSlidesClasses();
					}
					let r;
					if (
						(s.breakpoints && e.setBreakpoint(),
						[...e.el.querySelectorAll('[loading="lazy"]')].forEach((t) => {
							t.complete && F(e, t);
						}),
						e.updateSize(),
						e.updateSlides(),
						e.updateProgress(),
						e.updateSlidesClasses(),
						s.freeMode && s.freeMode.enabled && !s.cssMode)
					)
						i(), s.autoHeight && e.updateAutoHeight();
					else {
						if (
							("auto" === s.slidesPerView || s.slidesPerView > 1) &&
							e.isEnd &&
							!s.centeredSlides
						) {
							const t =
								e.virtual && s.virtual.enabled ? e.virtual.slides : e.slides;
							r = e.slideTo(t.length - 1, 0, !1, !0);
						} else r = e.slideTo(e.activeIndex, 0, !1, !0);
						r || i();
					}
					s.watchOverflow && t !== e.snapGrid && e.checkOverflow(),
						e.emit("update");
				}
				changeDirection(e, t) {
					void 0 === t && (t = !0);
					const s = this,
						i = s.params.direction;
					return (
						e || (e = "horizontal" === i ? "vertical" : "horizontal"),
						e === i ||
							("horizontal" !== e && "vertical" !== e) ||
							(s.el.classList.remove(`${s.params.containerModifierClass}${i}`),
							s.el.classList.add(`${s.params.containerModifierClass}${e}`),
							s.emitContainerClasses(),
							(s.params.direction = e),
							s.slides.forEach((t) => {
								"vertical" === e ? (t.style.width = "") : (t.style.height = "");
							}),
							s.emit("changeDirection"),
							t && s.update()),
						s
					);
				}
				changeLanguageDirection(e) {
					const t = this;
					(t.rtl && "rtl" === e) ||
						(!t.rtl && "ltr" === e) ||
						((t.rtl = "rtl" === e),
						(t.rtlTranslate = "horizontal" === t.params.direction && t.rtl),
						t.rtl
							? (t.el.classList.add(`${t.params.containerModifierClass}rtl`),
							  (t.el.dir = "rtl"))
							: (t.el.classList.remove(`${t.params.containerModifierClass}rtl`),
							  (t.el.dir = "ltr")),
						t.update());
				}
				mount(e) {
					const t = this;
					if (t.mounted) return !0;
					let s = e || t.params.el;
					if (("string" == typeof s && (s = document.querySelector(s)), !s))
						return !1;
					(s.swiper = t),
						s.parentNode &&
							s.parentNode.host &&
							s.parentNode.host.nodeName ===
								t.params.swiperElementNodeName.toUpperCase() &&
							(t.isElement = !0);
					const i = () =>
						`.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`;
					let r = (() => {
						if (s && s.shadowRoot && s.shadowRoot.querySelector) {
							return s.shadowRoot.querySelector(i());
						}
						return O(s, i())[0];
					})();
					return (
						!r &&
							t.params.createElements &&
							((r = M("div", t.params.wrapperClass)),
							s.append(r),
							O(s, `.${t.params.slideClass}`).forEach((e) => {
								r.append(e);
							})),
						Object.assign(t, {
							el: s,
							wrapperEl: r,
							slidesEl:
								t.isElement && !s.parentNode.host.slideSlots
									? s.parentNode.host
									: r,
							hostEl: t.isElement ? s.parentNode.host : s,
							mounted: !0,
							rtl: "rtl" === s.dir.toLowerCase() || "rtl" === k(s, "direction"),
							rtlTranslate:
								"horizontal" === t.params.direction &&
								("rtl" === s.dir.toLowerCase() || "rtl" === k(s, "direction")),
							wrongRTL: "-webkit-box" === k(r, "display"),
						}),
						!0
					);
				}
				init(e) {
					const t = this;
					if (t.initialized) return t;
					if (!1 === t.mount(e)) return t;
					t.emit("beforeInit"),
						t.params.breakpoints && t.setBreakpoint(),
						t.addClasses(),
						t.updateSize(),
						t.updateSlides(),
						t.params.watchOverflow && t.checkOverflow(),
						t.params.grabCursor && t.enabled && t.setGrabCursor(),
						t.params.loop && t.virtual && t.params.virtual.enabled
							? t.slideTo(
									t.params.initialSlide + t.virtual.slidesBefore,
									0,
									t.params.runCallbacksOnInit,
									!1,
									!0,
							  )
							: t.slideTo(
									t.params.initialSlide,
									0,
									t.params.runCallbacksOnInit,
									!1,
									!0,
							  ),
						t.params.loop && t.loopCreate(void 0, !0),
						t.attachEvents();
					const s = [...t.el.querySelectorAll('[loading="lazy"]')];
					return (
						t.isElement &&
							s.push(...t.hostEl.querySelectorAll('[loading="lazy"]')),
						s.forEach((e) => {
							e.complete
								? F(t, e)
								: e.addEventListener("load", (e) => {
										F(t, e.target);
								  });
						}),
						j(t),
						(t.initialized = !0),
						j(t),
						t.emit("init"),
						t.emit("afterInit"),
						t
					);
				}
				destroy(e, t) {
					void 0 === e && (e = !0), void 0 === t && (t = !0);
					const s = this,
						{ params: i, el: r, wrapperEl: n, slides: a } = s;
					return (
						void 0 === s.params ||
							s.destroyed ||
							(s.emit("beforeDestroy"),
							(s.initialized = !1),
							s.detachEvents(),
							i.loop && s.loopDestroy(),
							t &&
								(s.removeClasses(),
								r && "string" != typeof r && r.removeAttribute("style"),
								n && n.removeAttribute("style"),
								a &&
									a.length &&
									a.forEach((e) => {
										e.classList.remove(
											i.slideVisibleClass,
											i.slideFullyVisibleClass,
											i.slideActiveClass,
											i.slideNextClass,
											i.slidePrevClass,
										),
											e.removeAttribute("style"),
											e.removeAttribute("data-swiper-slide-index");
									})),
							s.emit("destroy"),
							Object.keys(s.eventsListeners).forEach((e) => {
								s.off(e);
							}),
							!1 !== e &&
								(s.el && "string" != typeof s.el && (s.el.swiper = null),
								(function (e) {
									const t = e;
									Object.keys(t).forEach((e) => {
										try {
											t[e] = null;
										} catch (e) {}
										try {
											delete t[e];
										} catch (e) {}
									});
								})(s)),
							(s.destroyed = !0)),
						null
					);
				}
				static extendDefaults(e) {
					T(ue, e);
				}
				static get extendedDefaults() {
					return ue;
				}
				static get defaults() {
					return ce;
				}
				static installModule(e) {
					he.prototype.__modules__ || (he.prototype.__modules__ = []);
					const t = he.prototype.__modules__;
					"function" == typeof e && t.indexOf(e) < 0 && t.push(e);
				}
				static use(e) {
					return Array.isArray(e)
						? (e.forEach((e) => he.installModule(e)), he)
						: (he.installModule(e), he);
				}
			}
			function me(e, t, s, i) {
				return (
					e.params.createElements &&
						Object.keys(i).forEach((r) => {
							if (!s[r] && !0 === s.auto) {
								let n = O(e.el, `.${i[r]}`)[0];
								n ||
									((n = M("div", i[r])), (n.className = i[r]), e.el.append(n)),
									(s[r] = n),
									(t[r] = n);
							}
						}),
					s
				);
			}
			function fe(e) {
				let { swiper: t, extendParams: s, on: i, emit: r } = e;
				function n(e) {
					let s;
					return e &&
						"string" == typeof e &&
						t.isElement &&
						((s = t.el.querySelector(e) || t.hostEl.querySelector(e)), s)
						? s
						: (e &&
								("string" == typeof e &&
									(s = [...document.querySelectorAll(e)]),
								t.params.uniqueNavElements &&
								"string" == typeof e &&
								s &&
								s.length > 1 &&
								1 === t.el.querySelectorAll(e).length
									? (s = t.el.querySelector(e))
									: s && 1 === s.length && (s = s[0])),
						  e && !s ? e : s);
				}
				function a(e, s) {
					const i = t.params.navigation;
					(e = I(e)).forEach((e) => {
						e &&
							(e.classList[s ? "add" : "remove"](...i.disabledClass.split(" ")),
							"BUTTON" === e.tagName && (e.disabled = s),
							t.params.watchOverflow &&
								t.enabled &&
								e.classList[t.isLocked ? "add" : "remove"](i.lockClass));
					});
				}
				function o() {
					const { nextEl: e, prevEl: s } = t.navigation;
					if (t.params.loop) return a(s, !1), void a(e, !1);
					a(s, t.isBeginning && !t.params.rewind),
						a(e, t.isEnd && !t.params.rewind);
				}
				function l(e) {
					e.preventDefault(),
						(!t.isBeginning || t.params.loop || t.params.rewind) &&
							(t.slidePrev(), r("navigationPrev"));
				}
				function c(e) {
					e.preventDefault(),
						(!t.isEnd || t.params.loop || t.params.rewind) &&
							(t.slideNext(), r("navigationNext"));
				}
				function d() {
					const e = t.params.navigation;
					if (
						((t.params.navigation = me(
							t,
							t.originalParams.navigation,
							t.params.navigation,
							{ nextEl: "swiper-button-next", prevEl: "swiper-button-prev" },
						)),
						!e.nextEl && !e.prevEl)
					)
						return;
					let s = n(e.nextEl),
						i = n(e.prevEl);
					Object.assign(t.navigation, { nextEl: s, prevEl: i }),
						(s = I(s)),
						(i = I(i));
					const r = (s, i) => {
						s && s.addEventListener("click", "next" === i ? c : l),
							!t.enabled && s && s.classList.add(...e.lockClass.split(" "));
					};
					s.forEach((e) => r(e, "next")), i.forEach((e) => r(e, "prev"));
				}
				function p() {
					let { nextEl: e, prevEl: s } = t.navigation;
					(e = I(e)), (s = I(s));
					const i = (e, s) => {
						e.removeEventListener("click", "next" === s ? c : l),
							e.classList.remove(
								...t.params.navigation.disabledClass.split(" "),
							);
					};
					e.forEach((e) => i(e, "next")), s.forEach((e) => i(e, "prev"));
				}
				s({
					navigation: {
						nextEl: null,
						prevEl: null,
						hideOnClick: !1,
						disabledClass: "swiper-button-disabled",
						hiddenClass: "swiper-button-hidden",
						lockClass: "swiper-button-lock",
						navigationDisabledClass: "swiper-navigation-disabled",
					},
				}),
					(t.navigation = { nextEl: null, prevEl: null }),
					i("init", () => {
						!1 === t.params.navigation.enabled ? u() : (d(), o());
					}),
					i("toEdge fromEdge lock unlock", () => {
						o();
					}),
					i("destroy", () => {
						p();
					}),
					i("enable disable", () => {
						let { nextEl: e, prevEl: s } = t.navigation;
						(e = I(e)),
							(s = I(s)),
							t.enabled
								? o()
								: [...e, ...s]
										.filter((e) => !!e)
										.forEach((e) =>
											e.classList.add(t.params.navigation.lockClass),
										);
					}),
					i("click", (e, s) => {
						let { nextEl: i, prevEl: n } = t.navigation;
						(i = I(i)), (n = I(n));
						const a = s.target;
						let o = n.includes(a) || i.includes(a);
						if (t.isElement && !o) {
							const e = s.path || (s.composedPath && s.composedPath());
							e && (o = e.find((e) => i.includes(e) || n.includes(e)));
						}
						if (t.params.navigation.hideOnClick && !o) {
							if (
								t.pagination &&
								t.params.pagination &&
								t.params.pagination.clickable &&
								(t.pagination.el === a || t.pagination.el.contains(a))
							)
								return;
							let e;
							i.length
								? (e = i[0].classList.contains(t.params.navigation.hiddenClass))
								: n.length &&
								  (e = n[0].classList.contains(
										t.params.navigation.hiddenClass,
								  )),
								r(!0 === e ? "navigationShow" : "navigationHide"),
								[...i, ...n]
									.filter((e) => !!e)
									.forEach((e) =>
										e.classList.toggle(t.params.navigation.hiddenClass),
									);
						}
					});
				const u = () => {
					t.el.classList.add(
						...t.params.navigation.navigationDisabledClass.split(" "),
					),
						p();
				};
				Object.assign(t.navigation, {
					enable: () => {
						t.el.classList.remove(
							...t.params.navigation.navigationDisabledClass.split(" "),
						),
							d(),
							o();
					},
					disable: u,
					update: o,
					init: d,
					destroy: p,
				});
			}
			function ge(e) {
				return (
					void 0 === e && (e = ""),
					`.${e
						.trim()
						.replace(/([\.:!+\/])/g, "\\$1")
						.replace(/ /g, ".")}`
				);
			}
			function ve(e) {
				let { swiper: t, extendParams: s, on: i, emit: r } = e;
				const n = "swiper-pagination";
				let a;
				s({
					pagination: {
						el: null,
						bulletElement: "span",
						clickable: !1,
						hideOnClick: !1,
						renderBullet: null,
						renderProgressbar: null,
						renderFraction: null,
						renderCustom: null,
						progressbarOpposite: !1,
						type: "bullets",
						dynamicBullets: !1,
						dynamicMainBullets: 1,
						formatFractionCurrent: (e) => e,
						formatFractionTotal: (e) => e,
						bulletClass: `${n}-bullet`,
						bulletActiveClass: `${n}-bullet-active`,
						modifierClass: `${n}-`,
						currentClass: `${n}-current`,
						totalClass: `${n}-total`,
						hiddenClass: `${n}-hidden`,
						progressbarFillClass: `${n}-progressbar-fill`,
						progressbarOppositeClass: `${n}-progressbar-opposite`,
						clickableClass: `${n}-clickable`,
						lockClass: `${n}-lock`,
						horizontalClass: `${n}-horizontal`,
						verticalClass: `${n}-vertical`,
						paginationDisabledClass: `${n}-disabled`,
					},
				}),
					(t.pagination = { el: null, bullets: [] });
				let o = 0;
				function l() {
					return (
						!t.params.pagination.el ||
						!t.pagination.el ||
						(Array.isArray(t.pagination.el) && 0 === t.pagination.el.length)
					);
				}
				function c(e, s) {
					const { bulletActiveClass: i } = t.params.pagination;
					e &&
						(e = e[("prev" === s ? "previous" : "next") + "ElementSibling"]) &&
						(e.classList.add(`${i}-${s}`),
						(e = e[("prev" === s ? "previous" : "next") + "ElementSibling"]) &&
							e.classList.add(`${i}-${s}-${s}`));
				}
				function d(e) {
					const s = e.target.closest(ge(t.params.pagination.bulletClass));
					if (!s) return;
					e.preventDefault();
					const i = _(s) * t.params.slidesPerGroup;
					if (t.params.loop) {
						if (t.realIndex === i) return;
						const e =
							((r = t.realIndex),
							(n = i),
							(a = t.slides.length),
							(n %= a) == 1 + (r %= a)
								? "next"
								: n === r - 1
								? "previous"
								: void 0);
						"next" === e
							? t.slideNext()
							: "previous" === e
							? t.slidePrev()
							: t.slideToLoop(i);
					} else t.slideTo(i);
					var r, n, a;
				}
				function p() {
					const e = t.rtl,
						s = t.params.pagination;
					if (l()) return;
					let i,
						n,
						d = t.pagination.el;
					d = I(d);
					const p =
							t.virtual && t.params.virtual.enabled
								? t.virtual.slides.length
								: t.slides.length,
						u = t.params.loop
							? Math.ceil(p / t.params.slidesPerGroup)
							: t.snapGrid.length;
					if (
						(t.params.loop
							? ((n = t.previousRealIndex || 0),
							  (i =
									t.params.slidesPerGroup > 1
										? Math.floor(t.realIndex / t.params.slidesPerGroup)
										: t.realIndex))
							: void 0 !== t.snapIndex
							? ((i = t.snapIndex), (n = t.previousSnapIndex))
							: ((n = t.previousIndex || 0), (i = t.activeIndex || 0)),
						"bullets" === s.type &&
							t.pagination.bullets &&
							t.pagination.bullets.length > 0)
					) {
						const r = t.pagination.bullets;
						let l, p, u;
						if (
							(s.dynamicBullets &&
								((a = z(r[0], t.isHorizontal() ? "width" : "height", !0)),
								d.forEach((e) => {
									e.style[t.isHorizontal() ? "width" : "height"] =
										a * (s.dynamicMainBullets + 4) + "px";
								}),
								s.dynamicMainBullets > 1 &&
									void 0 !== n &&
									((o += i - (n || 0)),
									o > s.dynamicMainBullets - 1
										? (o = s.dynamicMainBullets - 1)
										: o < 0 && (o = 0)),
								(l = Math.max(i - o, 0)),
								(p = l + (Math.min(r.length, s.dynamicMainBullets) - 1)),
								(u = (p + l) / 2)),
							r.forEach((e) => {
								const t = [
									...[
										"",
										"-next",
										"-next-next",
										"-prev",
										"-prev-prev",
										"-main",
									].map((e) => `${s.bulletActiveClass}${e}`),
								]
									.map((e) =>
										"string" == typeof e && e.includes(" ") ? e.split(" ") : e,
									)
									.flat();
								e.classList.remove(...t);
							}),
							d.length > 1)
						)
							r.forEach((e) => {
								const r = _(e);
								r === i
									? e.classList.add(...s.bulletActiveClass.split(" "))
									: t.isElement && e.setAttribute("part", "bullet"),
									s.dynamicBullets &&
										(r >= l &&
											r <= p &&
											e.classList.add(
												...`${s.bulletActiveClass}-main`.split(" "),
											),
										r === l && c(e, "prev"),
										r === p && c(e, "next"));
							});
						else {
							const e = r[i];
							if (
								(e && e.classList.add(...s.bulletActiveClass.split(" ")),
								t.isElement &&
									r.forEach((e, t) => {
										e.setAttribute(
											"part",
											t === i ? "bullet-active" : "bullet",
										);
									}),
								s.dynamicBullets)
							) {
								const e = r[l],
									t = r[p];
								for (let e = l; e <= p; e += 1)
									r[e] &&
										r[e].classList.add(
											...`${s.bulletActiveClass}-main`.split(" "),
										);
								c(e, "prev"), c(t, "next");
							}
						}
						if (s.dynamicBullets) {
							const i = Math.min(r.length, s.dynamicMainBullets + 4),
								n = (a * i - a) / 2 - u * a,
								o = e ? "right" : "left";
							r.forEach((e) => {
								e.style[t.isHorizontal() ? o : "top"] = `${n}px`;
							});
						}
					}
					d.forEach((e, n) => {
						if (
							("fraction" === s.type &&
								(e.querySelectorAll(ge(s.currentClass)).forEach((e) => {
									e.textContent = s.formatFractionCurrent(i + 1);
								}),
								e.querySelectorAll(ge(s.totalClass)).forEach((e) => {
									e.textContent = s.formatFractionTotal(u);
								})),
							"progressbar" === s.type)
						) {
							let r;
							r = s.progressbarOpposite
								? t.isHorizontal()
									? "vertical"
									: "horizontal"
								: t.isHorizontal()
								? "horizontal"
								: "vertical";
							const n = (i + 1) / u;
							let a = 1,
								o = 1;
							"horizontal" === r ? (a = n) : (o = n),
								e.querySelectorAll(ge(s.progressbarFillClass)).forEach((e) => {
									(e.style.transform = `translate3d(0,0,0) scaleX(${a}) scaleY(${o})`),
										(e.style.transitionDuration = `${t.params.speed}ms`);
								});
						}
						"custom" === s.type && s.renderCustom
							? ((e.innerHTML = s.renderCustom(t, i + 1, u)),
							  0 === n && r("paginationRender", e))
							: (0 === n && r("paginationRender", e), r("paginationUpdate", e)),
							t.params.watchOverflow &&
								t.enabled &&
								e.classList[t.isLocked ? "add" : "remove"](s.lockClass);
					});
				}
				function u() {
					const e = t.params.pagination;
					if (l()) return;
					const s =
						t.virtual && t.params.virtual.enabled
							? t.virtual.slides.length
							: t.grid && t.params.grid.rows > 1
							? t.slides.length / Math.ceil(t.params.grid.rows)
							: t.slides.length;
					let i = t.pagination.el;
					i = I(i);
					let n = "";
					if ("bullets" === e.type) {
						let i = t.params.loop
							? Math.ceil(s / t.params.slidesPerGroup)
							: t.snapGrid.length;
						t.params.freeMode && t.params.freeMode.enabled && i > s && (i = s);
						for (let s = 0; s < i; s += 1)
							e.renderBullet
								? (n += e.renderBullet.call(t, s, e.bulletClass))
								: (n += `<${e.bulletElement} ${
										t.isElement ? 'part="bullet"' : ""
								  } class="${e.bulletClass}"></${e.bulletElement}>`);
					}
					"fraction" === e.type &&
						(n = e.renderFraction
							? e.renderFraction.call(t, e.currentClass, e.totalClass)
							: `<span class="${e.currentClass}"></span> / <span class="${e.totalClass}"></span>`),
						"progressbar" === e.type &&
							(n = e.renderProgressbar
								? e.renderProgressbar.call(t, e.progressbarFillClass)
								: `<span class="${e.progressbarFillClass}"></span>`),
						(t.pagination.bullets = []),
						i.forEach((s) => {
							"custom" !== e.type && (s.innerHTML = n || ""),
								"bullets" === e.type &&
									t.pagination.bullets.push(
										...s.querySelectorAll(ge(e.bulletClass)),
									);
						}),
						"custom" !== e.type && r("paginationRender", i[0]);
				}
				function h() {
					t.params.pagination = me(
						t,
						t.originalParams.pagination,
						t.params.pagination,
						{ el: "swiper-pagination" },
					);
					const e = t.params.pagination;
					if (!e.el) return;
					let s;
					"string" == typeof e.el &&
						t.isElement &&
						(s = t.el.querySelector(e.el)),
						s ||
							"string" != typeof e.el ||
							(s = [...document.querySelectorAll(e.el)]),
						s || (s = e.el),
						s &&
							0 !== s.length &&
							(t.params.uniqueNavElements &&
								"string" == typeof e.el &&
								Array.isArray(s) &&
								s.length > 1 &&
								((s = [...t.el.querySelectorAll(e.el)]),
								s.length > 1 &&
									(s = s.find((e) => P(e, ".swiper")[0] === t.el))),
							Array.isArray(s) && 1 === s.length && (s = s[0]),
							Object.assign(t.pagination, { el: s }),
							(s = I(s)),
							s.forEach((s) => {
								"bullets" === e.type &&
									e.clickable &&
									s.classList.add(...(e.clickableClass || "").split(" ")),
									s.classList.add(e.modifierClass + e.type),
									s.classList.add(
										t.isHorizontal() ? e.horizontalClass : e.verticalClass,
									),
									"bullets" === e.type &&
										e.dynamicBullets &&
										(s.classList.add(`${e.modifierClass}${e.type}-dynamic`),
										(o = 0),
										e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)),
									"progressbar" === e.type &&
										e.progressbarOpposite &&
										s.classList.add(e.progressbarOppositeClass),
									e.clickable && s.addEventListener("click", d),
									t.enabled || s.classList.add(e.lockClass);
							}));
				}
				function m() {
					const e = t.params.pagination;
					if (l()) return;
					let s = t.pagination.el;
					s &&
						((s = I(s)),
						s.forEach((s) => {
							s.classList.remove(e.hiddenClass),
								s.classList.remove(e.modifierClass + e.type),
								s.classList.remove(
									t.isHorizontal() ? e.horizontalClass : e.verticalClass,
								),
								e.clickable &&
									(s.classList.remove(...(e.clickableClass || "").split(" ")),
									s.removeEventListener("click", d));
						})),
						t.pagination.bullets &&
							t.pagination.bullets.forEach((t) =>
								t.classList.remove(...e.bulletActiveClass.split(" ")),
							);
				}
				i("changeDirection", () => {
					if (!t.pagination || !t.pagination.el) return;
					const e = t.params.pagination;
					let { el: s } = t.pagination;
					(s = I(s)),
						s.forEach((s) => {
							s.classList.remove(e.horizontalClass, e.verticalClass),
								s.classList.add(
									t.isHorizontal() ? e.horizontalClass : e.verticalClass,
								);
						});
				}),
					i("init", () => {
						!1 === t.params.pagination.enabled ? f() : (h(), u(), p());
					}),
					i("activeIndexChange", () => {
						void 0 === t.snapIndex && p();
					}),
					i("snapIndexChange", () => {
						p();
					}),
					i("snapGridLengthChange", () => {
						u(), p();
					}),
					i("destroy", () => {
						m();
					}),
					i("enable disable", () => {
						let { el: e } = t.pagination;
						e &&
							((e = I(e)),
							e.forEach((e) =>
								e.classList[t.enabled ? "remove" : "add"](
									t.params.pagination.lockClass,
								),
							));
					}),
					i("lock unlock", () => {
						p();
					}),
					i("click", (e, s) => {
						const i = s.target,
							n = I(t.pagination.el);
						if (
							t.params.pagination.el &&
							t.params.pagination.hideOnClick &&
							n &&
							n.length > 0 &&
							!i.classList.contains(t.params.pagination.bulletClass)
						) {
							if (
								t.navigation &&
								((t.navigation.nextEl && i === t.navigation.nextEl) ||
									(t.navigation.prevEl && i === t.navigation.prevEl))
							)
								return;
							const e = n[0].classList.contains(
								t.params.pagination.hiddenClass,
							);
							r(!0 === e ? "paginationShow" : "paginationHide"),
								n.forEach((e) =>
									e.classList.toggle(t.params.pagination.hiddenClass),
								);
						}
					});
				const f = () => {
					t.el.classList.add(t.params.pagination.paginationDisabledClass);
					let { el: e } = t.pagination;
					e &&
						((e = I(e)),
						e.forEach((e) =>
							e.classList.add(t.params.pagination.paginationDisabledClass),
						)),
						m();
				};
				Object.assign(t.pagination, {
					enable: () => {
						t.el.classList.remove(t.params.pagination.paginationDisabledClass);
						let { el: e } = t.pagination;
						e &&
							((e = I(e)),
							e.forEach((e) =>
								e.classList.remove(t.params.pagination.paginationDisabledClass),
							)),
							h(),
							u(),
							p();
					},
					disable: f,
					render: u,
					update: p,
					init: h,
					destroy: m,
				});
			}
			function be(e) {
				let { swiper: t, extendParams: s, on: i, emit: r } = e;
				const n = g();
				let a,
					o,
					l,
					c,
					d = !1,
					p = null,
					u = null;
				function h() {
					if (!t.params.scrollbar.el || !t.scrollbar.el) return;
					const { scrollbar: e, rtlTranslate: s } = t,
						{ dragEl: i, el: r } = e,
						n = t.params.scrollbar,
						a = t.params.loop ? t.progressLoop : t.progress;
					let c = o,
						d = (l - o) * a;
					s
						? ((d = -d),
						  d > 0 ? ((c = o - d), (d = 0)) : -d + o > l && (c = l + d))
						: d < 0
						? ((c = o + d), (d = 0))
						: d + o > l && (c = l - d),
						t.isHorizontal()
							? ((i.style.transform = `translate3d(${d}px, 0, 0)`),
							  (i.style.width = `${c}px`))
							: ((i.style.transform = `translate3d(0px, ${d}px, 0)`),
							  (i.style.height = `${c}px`)),
						n.hide &&
							(clearTimeout(p),
							(r.style.opacity = 1),
							(p = setTimeout(() => {
								(r.style.opacity = 0), (r.style.transitionDuration = "400ms");
							}, 1e3)));
				}
				function m() {
					if (!t.params.scrollbar.el || !t.scrollbar.el) return;
					const { scrollbar: e } = t,
						{ dragEl: s, el: i } = e;
					(s.style.width = ""),
						(s.style.height = ""),
						(l = t.isHorizontal() ? i.offsetWidth : i.offsetHeight),
						(c =
							t.size /
							(t.virtualSize +
								t.params.slidesOffsetBefore -
								(t.params.centeredSlides ? t.snapGrid[0] : 0))),
						(o =
							"auto" === t.params.scrollbar.dragSize
								? l * c
								: parseInt(t.params.scrollbar.dragSize, 10)),
						t.isHorizontal()
							? (s.style.width = `${o}px`)
							: (s.style.height = `${o}px`),
						(i.style.display = c >= 1 ? "none" : ""),
						t.params.scrollbar.hide && (i.style.opacity = 0),
						t.params.watchOverflow &&
							t.enabled &&
							e.el.classList[t.isLocked ? "add" : "remove"](
								t.params.scrollbar.lockClass,
							);
				}
				function f(e) {
					return t.isHorizontal() ? e.clientX : e.clientY;
				}
				function v(e) {
					const { scrollbar: s, rtlTranslate: i } = t,
						{ el: r } = s;
					let n;
					(n =
						(f(e) -
							(function (e) {
								const t = b(),
									s = g(),
									i = e.getBoundingClientRect(),
									r = s.body,
									n = e.clientTop || r.clientTop || 0,
									a = e.clientLeft || r.clientLeft || 0,
									o = e === t ? t.scrollY : e.scrollTop,
									l = e === t ? t.scrollX : e.scrollLeft;
								return { top: i.top + o - n, left: i.left + l - a };
							})(r)[t.isHorizontal() ? "left" : "top"] -
							(null !== a ? a : o / 2)) /
						(l - o)),
						(n = Math.max(Math.min(n, 1), 0)),
						i && (n = 1 - n);
					const c =
						t.minTranslate() + (t.maxTranslate() - t.minTranslate()) * n;
					t.updateProgress(c),
						t.setTranslate(c),
						t.updateActiveIndex(),
						t.updateSlidesClasses();
				}
				function E(e) {
					const s = t.params.scrollbar,
						{ scrollbar: i, wrapperEl: n } = t,
						{ el: o, dragEl: l } = i;
					(d = !0),
						(a =
							e.target === l
								? f(e) -
								  e.target.getBoundingClientRect()[
										t.isHorizontal() ? "left" : "top"
								  ]
								: null),
						e.preventDefault(),
						e.stopPropagation(),
						(n.style.transitionDuration = "100ms"),
						(l.style.transitionDuration = "100ms"),
						v(e),
						clearTimeout(u),
						(o.style.transitionDuration = "0ms"),
						s.hide && (o.style.opacity = 1),
						t.params.cssMode &&
							(t.wrapperEl.style["scroll-snap-type"] = "none"),
						r("scrollbarDragStart", e);
				}
				function S(e) {
					const { scrollbar: s, wrapperEl: i } = t,
						{ el: n, dragEl: a } = s;
					d &&
						(e.preventDefault && e.cancelable
							? e.preventDefault()
							: (e.returnValue = !1),
						v(e),
						(i.style.transitionDuration = "0ms"),
						(n.style.transitionDuration = "0ms"),
						(a.style.transitionDuration = "0ms"),
						r("scrollbarDragMove", e));
				}
				function x(e) {
					const s = t.params.scrollbar,
						{ scrollbar: i, wrapperEl: n } = t,
						{ el: a } = i;
					d &&
						((d = !1),
						t.params.cssMode &&
							((t.wrapperEl.style["scroll-snap-type"] = ""),
							(n.style.transitionDuration = "")),
						s.hide &&
							(clearTimeout(u),
							(u = w(() => {
								(a.style.opacity = 0), (a.style.transitionDuration = "400ms");
							}, 1e3))),
						r("scrollbarDragEnd", e),
						s.snapOnRelease && t.slideToClosest());
				}
				function T(e) {
					const { scrollbar: s, params: i } = t,
						r = s.el;
					if (!r) return;
					const a = r,
						o = !!i.passiveListeners && { passive: !1, capture: !1 },
						l = !!i.passiveListeners && { passive: !0, capture: !1 };
					if (!a) return;
					const c = "on" === e ? "addEventListener" : "removeEventListener";
					a[c]("pointerdown", E, o),
						n[c]("pointermove", S, o),
						n[c]("pointerup", x, l);
				}
				function L() {
					const { scrollbar: e, el: s } = t;
					t.params.scrollbar = me(
						t,
						t.originalParams.scrollbar,
						t.params.scrollbar,
						{ el: "swiper-scrollbar" },
					);
					const i = t.params.scrollbar;
					if (!i.el) return;
					let r, a;
					if (
						("string" == typeof i.el &&
							t.isElement &&
							(r = t.el.querySelector(i.el)),
						r || "string" != typeof i.el)
					)
						r || (r = i.el);
					else if (((r = n.querySelectorAll(i.el)), !r.length)) return;
					t.params.uniqueNavElements &&
						"string" == typeof i.el &&
						r.length > 1 &&
						1 === s.querySelectorAll(i.el).length &&
						(r = s.querySelector(i.el)),
						r.length > 0 && (r = r[0]),
						r.classList.add(
							t.isHorizontal() ? i.horizontalClass : i.verticalClass,
						),
						r &&
							((a = r.querySelector(ge(t.params.scrollbar.dragClass))),
							a || ((a = M("div", t.params.scrollbar.dragClass)), r.append(a))),
						Object.assign(e, { el: r, dragEl: a }),
						i.draggable && t.params.scrollbar.el && t.scrollbar.el && T("on"),
						r &&
							r.classList[t.enabled ? "remove" : "add"](
								...y(t.params.scrollbar.lockClass),
							);
				}
				function C() {
					const e = t.params.scrollbar,
						s = t.scrollbar.el;
					s &&
						s.classList.remove(
							...y(t.isHorizontal() ? e.horizontalClass : e.verticalClass),
						),
						t.params.scrollbar.el && t.scrollbar.el && T("off");
				}
				s({
					scrollbar: {
						el: null,
						dragSize: "auto",
						hide: !1,
						draggable: !1,
						snapOnRelease: !0,
						lockClass: "swiper-scrollbar-lock",
						dragClass: "swiper-scrollbar-drag",
						scrollbarDisabledClass: "swiper-scrollbar-disabled",
						horizontalClass: "swiper-scrollbar-horizontal",
						verticalClass: "swiper-scrollbar-vertical",
					},
				}),
					(t.scrollbar = { el: null, dragEl: null }),
					i("changeDirection", () => {
						if (!t.scrollbar || !t.scrollbar.el) return;
						const e = t.params.scrollbar;
						let { el: s } = t.scrollbar;
						(s = I(s)),
							s.forEach((s) => {
								s.classList.remove(e.horizontalClass, e.verticalClass),
									s.classList.add(
										t.isHorizontal() ? e.horizontalClass : e.verticalClass,
									);
							});
					}),
					i("init", () => {
						!1 === t.params.scrollbar.enabled ? O() : (L(), m(), h());
					}),
					i("update resize observerUpdate lock unlock changeDirection", () => {
						m();
					}),
					i("setTranslate", () => {
						h();
					}),
					i("setTransition", (e, s) => {
						!(function (e) {
							t.params.scrollbar.el &&
								t.scrollbar.el &&
								(t.scrollbar.dragEl.style.transitionDuration = `${e}ms`);
						})(s);
					}),
					i("enable disable", () => {
						const { el: e } = t.scrollbar;
						e &&
							e.classList[t.enabled ? "remove" : "add"](
								...y(t.params.scrollbar.lockClass),
							);
					}),
					i("destroy", () => {
						C();
					});
				const O = () => {
					t.el.classList.add(...y(t.params.scrollbar.scrollbarDisabledClass)),
						t.scrollbar.el &&
							t.scrollbar.el.classList.add(
								...y(t.params.scrollbar.scrollbarDisabledClass),
							),
						C();
				};
				Object.assign(t.scrollbar, {
					enable: () => {
						t.el.classList.remove(
							...y(t.params.scrollbar.scrollbarDisabledClass),
						),
							t.scrollbar.el &&
								t.scrollbar.el.classList.remove(
									...y(t.params.scrollbar.scrollbarDisabledClass),
								),
							L(),
							m(),
							h();
					},
					disable: O,
					updateSize: m,
					setTranslate: h,
					init: L,
					destroy: C,
				});
			}
			function ye(e) {
				let t,
					s,
					{ swiper: i, extendParams: r, on: n, emit: a, params: o } = e;
				(i.autoplay = { running: !1, paused: !1, timeLeft: 0 }),
					r({
						autoplay: {
							enabled: !1,
							delay: 3e3,
							waitForTransition: !0,
							disableOnInteraction: !1,
							stopOnLastSlide: !1,
							reverseDirection: !1,
							pauseOnMouseEnter: !1,
						},
					});
				let l,
					c,
					d,
					p,
					u,
					h,
					m,
					f,
					v = o && o.autoplay ? o.autoplay.delay : 3e3,
					b = o && o.autoplay ? o.autoplay.delay : 3e3,
					y = new Date().getTime();
				function w(e) {
					i &&
						!i.destroyed &&
						i.wrapperEl &&
						e.target === i.wrapperEl &&
						(i.wrapperEl.removeEventListener("transitionend", w),
						f || (e.detail && e.detail.bySwiperTouchMove) || C());
				}
				const E = () => {
						if (i.destroyed || !i.autoplay.running) return;
						i.autoplay.paused ? (c = !0) : c && ((b = l), (c = !1));
						const e = i.autoplay.paused ? l : y + b - new Date().getTime();
						(i.autoplay.timeLeft = e),
							a("autoplayTimeLeft", e, e / v),
							(s = requestAnimationFrame(() => {
								E();
							}));
					},
					S = (e) => {
						if (i.destroyed || !i.autoplay.running) return;
						cancelAnimationFrame(s), E();
						let r = void 0 === e ? i.params.autoplay.delay : e;
						(v = i.params.autoplay.delay), (b = i.params.autoplay.delay);
						const n = (() => {
							let e;
							if (
								((e =
									i.virtual && i.params.virtual.enabled
										? i.slides.find((e) =>
												e.classList.contains("swiper-slide-active"),
										  )
										: i.slides[i.activeIndex]),
								!e)
							)
								return;
							return parseInt(e.getAttribute("data-swiper-autoplay"), 10);
						})();
						!Number.isNaN(n) &&
							n > 0 &&
							void 0 === e &&
							((r = n), (v = n), (b = n)),
							(l = r);
						const o = i.params.speed,
							c = () => {
								i &&
									!i.destroyed &&
									(i.params.autoplay.reverseDirection
										? !i.isBeginning || i.params.loop || i.params.rewind
											? (i.slidePrev(o, !0, !0), a("autoplay"))
											: i.params.autoplay.stopOnLastSlide ||
											  (i.slideTo(i.slides.length - 1, o, !0, !0),
											  a("autoplay"))
										: !i.isEnd || i.params.loop || i.params.rewind
										? (i.slideNext(o, !0, !0), a("autoplay"))
										: i.params.autoplay.stopOnLastSlide ||
										  (i.slideTo(0, o, !0, !0), a("autoplay")),
									i.params.cssMode &&
										((y = new Date().getTime()),
										requestAnimationFrame(() => {
											S();
										})));
							};
						return (
							r > 0
								? (clearTimeout(t),
								  (t = setTimeout(() => {
										c();
								  }, r)))
								: requestAnimationFrame(() => {
										c();
								  }),
							r
						);
					},
					x = () => {
						(y = new Date().getTime()),
							(i.autoplay.running = !0),
							S(),
							a("autoplayStart");
					},
					T = () => {
						(i.autoplay.running = !1),
							clearTimeout(t),
							cancelAnimationFrame(s),
							a("autoplayStop");
					},
					L = (e, s) => {
						if (i.destroyed || !i.autoplay.running) return;
						clearTimeout(t), e || (m = !0);
						const r = () => {
							a("autoplayPause"),
								i.params.autoplay.waitForTransition
									? i.wrapperEl.addEventListener("transitionend", w)
									: C();
						};
						if (((i.autoplay.paused = !0), s))
							return h && (l = i.params.autoplay.delay), (h = !1), void r();
						const n = l || i.params.autoplay.delay;
						(l = n - (new Date().getTime() - y)),
							(i.isEnd && l < 0 && !i.params.loop) || (l < 0 && (l = 0), r());
					},
					C = () => {
						(i.isEnd && l < 0 && !i.params.loop) ||
							i.destroyed ||
							!i.autoplay.running ||
							((y = new Date().getTime()),
							m ? ((m = !1), S(l)) : S(),
							(i.autoplay.paused = !1),
							a("autoplayResume"));
					},
					O = () => {
						if (i.destroyed || !i.autoplay.running) return;
						const e = g();
						"hidden" === e.visibilityState && ((m = !0), L(!0)),
							"visible" === e.visibilityState && C();
					},
					A = (e) => {
						"mouse" === e.pointerType &&
							((m = !0), (f = !0), i.animating || i.autoplay.paused || L(!0));
					},
					M = (e) => {
						"mouse" === e.pointerType && ((f = !1), i.autoplay.paused && C());
					};
				n("init", () => {
					i.params.autoplay.enabled &&
						(i.params.autoplay.pauseOnMouseEnter &&
							(i.el.addEventListener("pointerenter", A),
							i.el.addEventListener("pointerleave", M)),
						g().addEventListener("visibilitychange", O),
						x());
				}),
					n("destroy", () => {
						i.el &&
							"string" != typeof i.el &&
							(i.el.removeEventListener("pointerenter", A),
							i.el.removeEventListener("pointerleave", M)),
							g().removeEventListener("visibilitychange", O),
							i.autoplay.running && T();
					}),
					n("_freeModeStaticRelease", () => {
						(p || m) && C();
					}),
					n("_freeModeNoMomentumRelease", () => {
						i.params.autoplay.disableOnInteraction ? T() : L(!0, !0);
					}),
					n("beforeTransitionStart", (e, t, s) => {
						!i.destroyed &&
							i.autoplay.running &&
							(s || !i.params.autoplay.disableOnInteraction ? L(!0, !0) : T());
					}),
					n("sliderFirstMove", () => {
						!i.destroyed &&
							i.autoplay.running &&
							(i.params.autoplay.disableOnInteraction
								? T()
								: ((d = !0),
								  (p = !1),
								  (m = !1),
								  (u = setTimeout(() => {
										(m = !0), (p = !0), L(!0);
								  }, 200))));
					}),
					n("touchEnd", () => {
						if (!i.destroyed && i.autoplay.running && d) {
							if (
								(clearTimeout(u),
								clearTimeout(t),
								i.params.autoplay.disableOnInteraction)
							)
								return (p = !1), void (d = !1);
							p && i.params.cssMode && C(), (p = !1), (d = !1);
						}
					}),
					n("slideChange", () => {
						!i.destroyed && i.autoplay.running && (h = !0);
					}),
					Object.assign(i.autoplay, { start: x, stop: T, pause: L, resume: C });
			}
			Object.keys(pe).forEach((e) => {
				Object.keys(pe[e]).forEach((t) => {
					he.prototype[t] = pe[e][t];
				});
			}),
				he.use([
					function (e) {
						let { swiper: t, on: s, emit: i } = e;
						const r = b();
						let n = null,
							a = null;
						const o = () => {
								t &&
									!t.destroyed &&
									t.initialized &&
									(i("beforeResize"), i("resize"));
							},
							l = () => {
								t && !t.destroyed && t.initialized && i("orientationchange");
							};
						s("init", () => {
							t.params.resizeObserver && void 0 !== r.ResizeObserver
								? t &&
								  !t.destroyed &&
								  t.initialized &&
								  ((n = new ResizeObserver((e) => {
										a = r.requestAnimationFrame(() => {
											const { width: s, height: i } = t;
											let r = s,
												n = i;
											e.forEach((e) => {
												let {
													contentBoxSize: s,
													contentRect: i,
													target: a,
												} = e;
												(a && a !== t.el) ||
													((r = i ? i.width : (s[0] || s).inlineSize),
													(n = i ? i.height : (s[0] || s).blockSize));
											}),
												(r === s && n === i) || o();
										});
								  })),
								  n.observe(t.el))
								: (r.addEventListener("resize", o),
								  r.addEventListener("orientationchange", l));
						}),
							s("destroy", () => {
								a && r.cancelAnimationFrame(a),
									n && n.unobserve && t.el && (n.unobserve(t.el), (n = null)),
									r.removeEventListener("resize", o),
									r.removeEventListener("orientationchange", l);
							});
					},
					function (e) {
						let { swiper: t, extendParams: s, on: i, emit: r } = e;
						const n = [],
							a = b(),
							o = function (e, s) {
								void 0 === s && (s = {});
								const i = new (a.MutationObserver || a.WebkitMutationObserver)(
									(e) => {
										if (t.__preventObserver__) return;
										if (1 === e.length) return void r("observerUpdate", e[0]);
										const s = function () {
											r("observerUpdate", e[0]);
										};
										a.requestAnimationFrame
											? a.requestAnimationFrame(s)
											: a.setTimeout(s, 0);
									},
								);
								i.observe(e, {
									attributes: void 0 === s.attributes || s.attributes,
									childList:
										t.isElement || (void 0 === s.childList || s).childList,
									characterData: void 0 === s.characterData || s.characterData,
								}),
									n.push(i);
							};
						s({ observer: !1, observeParents: !1, observeSlideChildren: !1 }),
							i("init", () => {
								if (t.params.observer) {
									if (t.params.observeParents) {
										const e = P(t.hostEl);
										for (let t = 0; t < e.length; t += 1) o(e[t]);
									}
									o(t.hostEl, { childList: t.params.observeSlideChildren }),
										o(t.wrapperEl, { attributes: !1 });
								}
							}),
							i("destroy", () => {
								n.forEach((e) => {
									e.disconnect();
								}),
									n.splice(0, n.length);
							});
					},
				]),
				window.addEventListener("load", function (e) {
					!(function () {
						let e = null;
						function t() {
							const t = document.querySelector(".reviews__slider"),
								s = window.innerWidth;
							s < 1024 && t && !e
								? (e = new he(t, {
										modules: [fe, ye],
										observer: !0,
										observeParents: !0,
										slidesPerView: 1,
										speed: 800,
										autoplay: { delay: 3e3, disableOnInteraction: !1 },
										breakpoints: {
											0: {
												slidesPerView: 1.3,
												spaceBetween: 24,
												autoHeight: !0,
											},
											480: { slidesPerView: 2.5, spaceBetween: 24 },
											1024: { slidesPerView: 3.3, spaceBetween: 24 },
										},
										navigation: {
											prevEl: ".swiper-button-prev",
											nextEl: ".swiper-button-next",
										},
								  }))
								: (s >= 1024 || !t) && e && (e.destroy(!0, !0), (e = null));
						}
						const s = document.querySelector(".trading-indicators__swiper");
						if (s) {
							let n = !1;
							function a() {
								window.innerWidth <= 479.98
									? n || s.classList.add("_scrolling")
									: (s.classList.remove("_scrolling"), (n = !1));
							}
							new he(".trading-indicators__swiper", {
								modules: [ye, ve],
								observer: !0,
								observeParents: !0,
								speed: 800,
								slidesPerView: 1,
								spaceBetween: 0,
								pagination: {
									el: ".trading-indicators__pagination",
									clickable: !0,
								},
								breakpoints: {
									0: { slidesPerView: 1.2, spaceBetween: 16 },
									480: { slidesPerView: 1, spaceBetween: 10 },
								},
								on: {
									init: function () {
										window.innerWidth <= 479.98 &&
											s.classList.add("_scrolling");
									},
									touchStart: function () {
										window.innerWidth <= 479.98 &&
											!n &&
											((n = !0), s.classList.remove("_scrolling"));
									},
									slideChange: function () {
										window.innerWidth <= 479.98 &&
											((n = !0), s.classList.remove("_scrolling"));
									},
								},
							}),
								window.addEventListener("resize", a);
						}
						t(),
							window.addEventListener("resize", t),
							(function () {
								const e = document.querySelectorAll(".tariff-cards");
								e.length &&
									e.forEach((e) => {
										new he(e, {
											modules: [ve],
											observer: !0,
											observeParents: !0,
											slidesPerView: 1.2,
											spaceBetween: 24,
											speed: 800,
											pagination: {
												el: ".tariff-cards-pagination",
												clickable: !0,
											},
											breakpoints: {
												320: {
													slidesPerView: 1.3,
													spaceBetween: 14,
													initialSlide: 1,
													centeredSlides: !0,
												},
												768: {
													slidesPerView: 2.1,
													spaceBetween: 20,
													centeredSlides: !1,
												},
												1024: { slidesPerView: 3, spaceBetween: 24 },
											},
										});
									});
							})(),
							document.querySelector(".block__slider") &&
								new he(".block__slider", {
									modules: [ye],
									observer: !0,
									observeParents: !0,
									speed: 800,
									autoplay: { delay: 3e3, disableOnInteraction: !1 },
									breakpoints: {
										0: { slidesPerView: 1.9, spaceBetween: 24 },
										480: { slidesPerView: 2.5, spaceBetween: 62 },
										1024: { slidesPerView: 3, spaceBetween: 72 },
									},
									on: {},
								});
						let i = [];
						function r() {
							const e = document.querySelectorAll(".pattern__slider"),
								t = window.innerWidth;
							i.forEach((e) => e.destroy(!0, !0)),
								(i = []),
								t < 1024 &&
									e.length > 0 &&
									e.forEach((e) => {
										const t = new he(e, {
											modules: [be, ye],
											observer: !0,
											observeParents: !0,
											slidesPerView: 1,
											speed: 800,
											autoplay: { delay: 3e3, disableOnInteraction: !1 },
											scrollbar: { el: ".swiper-scrollbar", draggable: !0 },
											breakpoints: {
												0: { slidesPerView: 1.19, spaceBetween: 12 },
												480: { slidesPerView: 2.5, spaceBetween: 24 },
												1024: { slidesPerView: 3.3, spaceBetween: 24 },
											},
										});
										i.push(t);
									});
						}
						r(), window.addEventListener("resize", r);
					})();
				});
			var we = s(221),
				Ee = s(969),
				Se = function () {
					return (
						(Se =
							Object.assign ||
							function (e) {
								for (var t, s = 1, i = arguments.length; s < i; s++)
									for (var r in (t = arguments[s]))
										Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
								return e;
							}),
						Se.apply(this, arguments)
					);
				};
			function xe(e) {
				return e && e.ownerDocument && e.ownerDocument.defaultView
					? e.ownerDocument.defaultView
					: window;
			}
			function Te(e) {
				return e && e.ownerDocument ? e.ownerDocument : document;
			}
			var Le = function (e) {
				return Array.prototype.reduce.call(
					e,
					function (e, t) {
						var s = t.name.match(/data-simplebar-(.+)/);
						if (s) {
							var i = s[1].replace(/\W+(.)/g, function (e, t) {
								return t.toUpperCase();
							});
							switch (t.value) {
								case "true":
									e[i] = !0;
									break;
								case "false":
									e[i] = !1;
									break;
								case void 0:
									e[i] = !0;
									break;
								default:
									e[i] = t.value;
							}
						}
						return e;
					},
					{},
				);
			};
			function Ce(e, t) {
				var s;
				e && (s = e.classList).add.apply(s, t.split(" "));
			}
			function Oe(e, t) {
				e &&
					t.split(" ").forEach(function (t) {
						e.classList.remove(t);
					});
			}
			function Ae(e) {
				return ".".concat(e.split(" ").join("."));
			}
			var Me = !(
					"undefined" == typeof window ||
					!window.document ||
					!window.document.createElement
				),
				ke = Object.freeze({
					__proto__: null,
					addClasses: Ce,
					canUseDOM: Me,
					classNamesToQuery: Ae,
					getElementDocument: Te,
					getElementWindow: xe,
					getOptions: Le,
					removeClasses: Oe,
				}),
				_e = null,
				Pe = null;
			function ze() {
				if (null === _e) {
					if ("undefined" == typeof document) return (_e = 0);
					var e = document.body,
						t = document.createElement("div");
					t.classList.add("simplebar-hide-scrollbar"), e.appendChild(t);
					var s = t.getBoundingClientRect().right;
					e.removeChild(t), (_e = s);
				}
				return _e;
			}
			Me &&
				window.addEventListener("resize", function () {
					Pe !== window.devicePixelRatio &&
						((Pe = window.devicePixelRatio), (_e = null));
				});
			var Ie = xe,
				De = Te,
				$e = Le,
				Be = Ce,
				We = Oe,
				Ne = Ae,
				qe = (function () {
					function e(t, s) {
						void 0 === s && (s = {});
						var i = this;
						if (
							((this.removePreventClickId = null),
							(this.minScrollbarWidth = 20),
							(this.stopScrollDelay = 175),
							(this.isScrolling = !1),
							(this.isMouseEntering = !1),
							(this.isDragging = !1),
							(this.scrollXTicking = !1),
							(this.scrollYTicking = !1),
							(this.wrapperEl = null),
							(this.contentWrapperEl = null),
							(this.contentEl = null),
							(this.offsetEl = null),
							(this.maskEl = null),
							(this.placeholderEl = null),
							(this.heightAutoObserverWrapperEl = null),
							(this.heightAutoObserverEl = null),
							(this.rtlHelpers = null),
							(this.scrollbarWidth = 0),
							(this.resizeObserver = null),
							(this.mutationObserver = null),
							(this.elStyles = null),
							(this.isRtl = null),
							(this.mouseX = 0),
							(this.mouseY = 0),
							(this.onMouseMove = function () {}),
							(this.onWindowResize = function () {}),
							(this.onStopScrolling = function () {}),
							(this.onMouseEntered = function () {}),
							(this.onScroll = function () {
								var e = Ie(i.el);
								i.scrollXTicking ||
									(e.requestAnimationFrame(i.scrollX), (i.scrollXTicking = !0)),
									i.scrollYTicking ||
										(e.requestAnimationFrame(i.scrollY),
										(i.scrollYTicking = !0)),
									i.isScrolling ||
										((i.isScrolling = !0), Be(i.el, i.classNames.scrolling)),
									i.showScrollbar("x"),
									i.showScrollbar("y"),
									i.onStopScrolling();
							}),
							(this.scrollX = function () {
								i.axis.x.isOverflowing && i.positionScrollbar("x"),
									(i.scrollXTicking = !1);
							}),
							(this.scrollY = function () {
								i.axis.y.isOverflowing && i.positionScrollbar("y"),
									(i.scrollYTicking = !1);
							}),
							(this._onStopScrolling = function () {
								We(i.el, i.classNames.scrolling),
									i.options.autoHide &&
										(i.hideScrollbar("x"), i.hideScrollbar("y")),
									(i.isScrolling = !1);
							}),
							(this.onMouseEnter = function () {
								i.isMouseEntering ||
									(Be(i.el, i.classNames.mouseEntered),
									i.showScrollbar("x"),
									i.showScrollbar("y"),
									(i.isMouseEntering = !0)),
									i.onMouseEntered();
							}),
							(this._onMouseEntered = function () {
								We(i.el, i.classNames.mouseEntered),
									i.options.autoHide &&
										(i.hideScrollbar("x"), i.hideScrollbar("y")),
									(i.isMouseEntering = !1);
							}),
							(this._onMouseMove = function (e) {
								(i.mouseX = e.clientX),
									(i.mouseY = e.clientY),
									(i.axis.x.isOverflowing || i.axis.x.forceVisible) &&
										i.onMouseMoveForAxis("x"),
									(i.axis.y.isOverflowing || i.axis.y.forceVisible) &&
										i.onMouseMoveForAxis("y");
							}),
							(this.onMouseLeave = function () {
								i.onMouseMove.cancel(),
									(i.axis.x.isOverflowing || i.axis.x.forceVisible) &&
										i.onMouseLeaveForAxis("x"),
									(i.axis.y.isOverflowing || i.axis.y.forceVisible) &&
										i.onMouseLeaveForAxis("y"),
									(i.mouseX = -1),
									(i.mouseY = -1);
							}),
							(this._onWindowResize = function () {
								(i.scrollbarWidth = i.getScrollbarWidth()),
									i.hideNativeScrollbar();
							}),
							(this.onPointerEvent = function (e) {
								var t, s;
								i.axis.x.track.el &&
									i.axis.y.track.el &&
									i.axis.x.scrollbar.el &&
									i.axis.y.scrollbar.el &&
									((i.axis.x.track.rect =
										i.axis.x.track.el.getBoundingClientRect()),
									(i.axis.y.track.rect =
										i.axis.y.track.el.getBoundingClientRect()),
									(i.axis.x.isOverflowing || i.axis.x.forceVisible) &&
										(t = i.isWithinBounds(i.axis.x.track.rect)),
									(i.axis.y.isOverflowing || i.axis.y.forceVisible) &&
										(s = i.isWithinBounds(i.axis.y.track.rect)),
									(t || s) &&
										(e.stopPropagation(),
										"pointerdown" === e.type &&
											"touch" !== e.pointerType &&
											(t &&
												((i.axis.x.scrollbar.rect =
													i.axis.x.scrollbar.el.getBoundingClientRect()),
												i.isWithinBounds(i.axis.x.scrollbar.rect)
													? i.onDragStart(e, "x")
													: i.onTrackClick(e, "x")),
											s &&
												((i.axis.y.scrollbar.rect =
													i.axis.y.scrollbar.el.getBoundingClientRect()),
												i.isWithinBounds(i.axis.y.scrollbar.rect)
													? i.onDragStart(e, "y")
													: i.onTrackClick(e, "y")))));
							}),
							(this.drag = function (t) {
								var s, r, n, a, o, l, c, d, p, u, h;
								if (i.draggedAxis && i.contentWrapperEl) {
									var m = i.axis[i.draggedAxis].track,
										f =
											null !==
												(r =
													null === (s = m.rect) || void 0 === s
														? void 0
														: s[i.axis[i.draggedAxis].sizeAttr]) && void 0 !== r
												? r
												: 0,
										g = i.axis[i.draggedAxis].scrollbar,
										v =
											null !==
												(a =
													null === (n = i.contentWrapperEl) || void 0 === n
														? void 0
														: n[i.axis[i.draggedAxis].scrollSizeAttr]) &&
											void 0 !== a
												? a
												: 0,
										b = parseInt(
											null !==
												(l =
													null === (o = i.elStyles) || void 0 === o
														? void 0
														: o[i.axis[i.draggedAxis].sizeAttr]) && void 0 !== l
												? l
												: "0px",
											10,
										);
									t.preventDefault(), t.stopPropagation();
									var y =
											("y" === i.draggedAxis ? t.pageY : t.pageX) -
											(null !==
												(d =
													null === (c = m.rect) || void 0 === c
														? void 0
														: c[i.axis[i.draggedAxis].offsetAttr]) &&
											void 0 !== d
												? d
												: 0) -
											i.axis[i.draggedAxis].dragOffset,
										w =
											((y =
												"x" === i.draggedAxis && i.isRtl
													? (null !==
															(u =
																null === (p = m.rect) || void 0 === p
																	? void 0
																	: p[i.axis[i.draggedAxis].sizeAttr]) &&
													  void 0 !== u
															? u
															: 0) -
													  g.size -
													  y
													: y) /
												(f - g.size)) *
											(v - b);
									"x" === i.draggedAxis &&
										i.isRtl &&
										(w = (
											null === (h = e.getRtlHelpers()) || void 0 === h
												? void 0
												: h.isScrollingToNegative
										)
											? -w
											: w),
										(i.contentWrapperEl[
											i.axis[i.draggedAxis].scrollOffsetAttr
										] = w);
								}
							}),
							(this.onEndDrag = function (e) {
								i.isDragging = !1;
								var t = De(i.el),
									s = Ie(i.el);
								e.preventDefault(),
									e.stopPropagation(),
									We(i.el, i.classNames.dragging),
									i.onStopScrolling(),
									t.removeEventListener("mousemove", i.drag, !0),
									t.removeEventListener("mouseup", i.onEndDrag, !0),
									(i.removePreventClickId = s.setTimeout(function () {
										t.removeEventListener("click", i.preventClick, !0),
											t.removeEventListener("dblclick", i.preventClick, !0),
											(i.removePreventClickId = null);
									}));
							}),
							(this.preventClick = function (e) {
								e.preventDefault(), e.stopPropagation();
							}),
							(this.el = t),
							(this.options = Se(Se({}, e.defaultOptions), s)),
							(this.classNames = Se(
								Se({}, e.defaultOptions.classNames),
								s.classNames,
							)),
							(this.axis = {
								x: {
									scrollOffsetAttr: "scrollLeft",
									sizeAttr: "width",
									scrollSizeAttr: "scrollWidth",
									offsetSizeAttr: "offsetWidth",
									offsetAttr: "left",
									overflowAttr: "overflowX",
									dragOffset: 0,
									isOverflowing: !0,
									forceVisible: !1,
									track: { size: null, el: null, rect: null, isVisible: !1 },
									scrollbar: {
										size: null,
										el: null,
										rect: null,
										isVisible: !1,
									},
								},
								y: {
									scrollOffsetAttr: "scrollTop",
									sizeAttr: "height",
									scrollSizeAttr: "scrollHeight",
									offsetSizeAttr: "offsetHeight",
									offsetAttr: "top",
									overflowAttr: "overflowY",
									dragOffset: 0,
									isOverflowing: !0,
									forceVisible: !1,
									track: { size: null, el: null, rect: null, isVisible: !1 },
									scrollbar: {
										size: null,
										el: null,
										rect: null,
										isVisible: !1,
									},
								},
							}),
							"object" != typeof this.el || !this.el.nodeName)
						)
							throw new Error(
								"Argument passed to SimpleBar must be an HTML element instead of ".concat(
									this.el,
								),
							);
						(this.onMouseMove = Ee(this._onMouseMove, 64)),
							(this.onWindowResize = we(this._onWindowResize, 64, {
								leading: !0,
							})),
							(this.onStopScrolling = we(
								this._onStopScrolling,
								this.stopScrollDelay,
							)),
							(this.onMouseEntered = we(
								this._onMouseEntered,
								this.stopScrollDelay,
							)),
							this.init();
					}
					return (
						(e.getRtlHelpers = function () {
							if (e.rtlHelpers) return e.rtlHelpers;
							var t = document.createElement("div");
							t.innerHTML =
								'<div class="simplebar-dummy-scrollbar-size"><div></div></div>';
							var s = t.firstElementChild,
								i = null == s ? void 0 : s.firstElementChild;
							if (!i) return null;
							document.body.appendChild(s), (s.scrollLeft = 0);
							var r = e.getOffset(s),
								n = e.getOffset(i);
							s.scrollLeft = -999;
							var a = e.getOffset(i);
							return (
								document.body.removeChild(s),
								(e.rtlHelpers = {
									isScrollOriginAtZero: r.left !== n.left,
									isScrollingToNegative: n.left !== a.left,
								}),
								e.rtlHelpers
							);
						}),
						(e.prototype.getScrollbarWidth = function () {
							try {
								return (this.contentWrapperEl &&
									"none" ===
										getComputedStyle(
											this.contentWrapperEl,
											"::-webkit-scrollbar",
										).display) ||
									"scrollbarWidth" in document.documentElement.style ||
									"-ms-overflow-style" in document.documentElement.style
									? 0
									: ze();
							} catch (e) {
								return ze();
							}
						}),
						(e.getOffset = function (e) {
							var t = e.getBoundingClientRect(),
								s = De(e),
								i = Ie(e);
							return {
								top: t.top + (i.pageYOffset || s.documentElement.scrollTop),
								left: t.left + (i.pageXOffset || s.documentElement.scrollLeft),
							};
						}),
						(e.prototype.init = function () {
							Me &&
								(this.initDOM(),
								(this.rtlHelpers = e.getRtlHelpers()),
								(this.scrollbarWidth = this.getScrollbarWidth()),
								this.recalculate(),
								this.initListeners());
						}),
						(e.prototype.initDOM = function () {
							var e, t;
							(this.wrapperEl = this.el.querySelector(
								Ne(this.classNames.wrapper),
							)),
								(this.contentWrapperEl =
									this.options.scrollableNode ||
									this.el.querySelector(Ne(this.classNames.contentWrapper))),
								(this.contentEl =
									this.options.contentNode ||
									this.el.querySelector(Ne(this.classNames.contentEl))),
								(this.offsetEl = this.el.querySelector(
									Ne(this.classNames.offset),
								)),
								(this.maskEl = this.el.querySelector(Ne(this.classNames.mask))),
								(this.placeholderEl = this.findChild(
									this.wrapperEl,
									Ne(this.classNames.placeholder),
								)),
								(this.heightAutoObserverWrapperEl = this.el.querySelector(
									Ne(this.classNames.heightAutoObserverWrapperEl),
								)),
								(this.heightAutoObserverEl = this.el.querySelector(
									Ne(this.classNames.heightAutoObserverEl),
								)),
								(this.axis.x.track.el = this.findChild(
									this.el,
									""
										.concat(Ne(this.classNames.track))
										.concat(Ne(this.classNames.horizontal)),
								)),
								(this.axis.y.track.el = this.findChild(
									this.el,
									""
										.concat(Ne(this.classNames.track))
										.concat(Ne(this.classNames.vertical)),
								)),
								(this.axis.x.scrollbar.el =
									(null === (e = this.axis.x.track.el) || void 0 === e
										? void 0
										: e.querySelector(Ne(this.classNames.scrollbar))) || null),
								(this.axis.y.scrollbar.el =
									(null === (t = this.axis.y.track.el) || void 0 === t
										? void 0
										: t.querySelector(Ne(this.classNames.scrollbar))) || null),
								this.options.autoHide ||
									(Be(this.axis.x.scrollbar.el, this.classNames.visible),
									Be(this.axis.y.scrollbar.el, this.classNames.visible));
						}),
						(e.prototype.initListeners = function () {
							var e,
								t = this,
								s = Ie(this.el);
							if (
								(this.el.addEventListener("mouseenter", this.onMouseEnter),
								this.el.addEventListener(
									"pointerdown",
									this.onPointerEvent,
									!0,
								),
								this.el.addEventListener("mousemove", this.onMouseMove),
								this.el.addEventListener("mouseleave", this.onMouseLeave),
								null === (e = this.contentWrapperEl) ||
									void 0 === e ||
									e.addEventListener("scroll", this.onScroll),
								s.addEventListener("resize", this.onWindowResize),
								this.contentEl)
							) {
								if (window.ResizeObserver) {
									var i = !1,
										r = s.ResizeObserver || ResizeObserver;
									(this.resizeObserver = new r(function () {
										i &&
											s.requestAnimationFrame(function () {
												t.recalculate();
											});
									})),
										this.resizeObserver.observe(this.el),
										this.resizeObserver.observe(this.contentEl),
										s.requestAnimationFrame(function () {
											i = !0;
										});
								}
								(this.mutationObserver = new s.MutationObserver(function () {
									s.requestAnimationFrame(function () {
										t.recalculate();
									});
								})),
									this.mutationObserver.observe(this.contentEl, {
										childList: !0,
										subtree: !0,
										characterData: !0,
									});
							}
						}),
						(e.prototype.recalculate = function () {
							if (
								this.heightAutoObserverEl &&
								this.contentEl &&
								this.contentWrapperEl &&
								this.wrapperEl &&
								this.placeholderEl
							) {
								var e = Ie(this.el);
								(this.elStyles = e.getComputedStyle(this.el)),
									(this.isRtl = "rtl" === this.elStyles.direction);
								var t = this.contentEl.offsetWidth,
									s = this.heightAutoObserverEl.offsetHeight <= 1,
									i = this.heightAutoObserverEl.offsetWidth <= 1 || t > 0,
									r = this.contentWrapperEl.offsetWidth,
									n = this.elStyles.overflowX,
									a = this.elStyles.overflowY;
								(this.contentEl.style.padding = ""
									.concat(this.elStyles.paddingTop, " ")
									.concat(this.elStyles.paddingRight, " ")
									.concat(this.elStyles.paddingBottom, " ")
									.concat(this.elStyles.paddingLeft)),
									(this.wrapperEl.style.margin = "-"
										.concat(this.elStyles.paddingTop, " -")
										.concat(this.elStyles.paddingRight, " -")
										.concat(this.elStyles.paddingBottom, " -")
										.concat(this.elStyles.paddingLeft));
								var o = this.contentEl.scrollHeight,
									l = this.contentEl.scrollWidth;
								(this.contentWrapperEl.style.height = s ? "auto" : "100%"),
									(this.placeholderEl.style.width = i
										? "".concat(t || l, "px")
										: "auto"),
									(this.placeholderEl.style.height = "".concat(o, "px"));
								var c = this.contentWrapperEl.offsetHeight;
								(this.axis.x.isOverflowing = 0 !== t && l > t),
									(this.axis.y.isOverflowing = o > c),
									(this.axis.x.isOverflowing =
										"hidden" !== n && this.axis.x.isOverflowing),
									(this.axis.y.isOverflowing =
										"hidden" !== a && this.axis.y.isOverflowing),
									(this.axis.x.forceVisible =
										"x" === this.options.forceVisible ||
										!0 === this.options.forceVisible),
									(this.axis.y.forceVisible =
										"y" === this.options.forceVisible ||
										!0 === this.options.forceVisible),
									this.hideNativeScrollbar();
								var d = this.axis.x.isOverflowing ? this.scrollbarWidth : 0,
									p = this.axis.y.isOverflowing ? this.scrollbarWidth : 0;
								(this.axis.x.isOverflowing =
									this.axis.x.isOverflowing && l > r - p),
									(this.axis.y.isOverflowing =
										this.axis.y.isOverflowing && o > c - d),
									(this.axis.x.scrollbar.size = this.getScrollbarSize("x")),
									(this.axis.y.scrollbar.size = this.getScrollbarSize("y")),
									this.axis.x.scrollbar.el &&
										(this.axis.x.scrollbar.el.style.width = "".concat(
											this.axis.x.scrollbar.size,
											"px",
										)),
									this.axis.y.scrollbar.el &&
										(this.axis.y.scrollbar.el.style.height = "".concat(
											this.axis.y.scrollbar.size,
											"px",
										)),
									this.positionScrollbar("x"),
									this.positionScrollbar("y"),
									this.toggleTrackVisibility("x"),
									this.toggleTrackVisibility("y");
							}
						}),
						(e.prototype.getScrollbarSize = function (e) {
							var t, s;
							if (
								(void 0 === e && (e = "y"),
								!this.axis[e].isOverflowing || !this.contentEl)
							)
								return 0;
							var i,
								r = this.contentEl[this.axis[e].scrollSizeAttr],
								n =
									null !==
										(s =
											null === (t = this.axis[e].track.el) || void 0 === t
												? void 0
												: t[this.axis[e].offsetSizeAttr]) && void 0 !== s
										? s
										: 0,
								a = n / r;
							return (
								(i = Math.max(~~(a * n), this.options.scrollbarMinSize)),
								this.options.scrollbarMaxSize &&
									(i = Math.min(i, this.options.scrollbarMaxSize)),
								i
							);
						}),
						(e.prototype.positionScrollbar = function (t) {
							var s, i, r;
							void 0 === t && (t = "y");
							var n = this.axis[t].scrollbar;
							if (
								this.axis[t].isOverflowing &&
								this.contentWrapperEl &&
								n.el &&
								this.elStyles
							) {
								var a = this.contentWrapperEl[this.axis[t].scrollSizeAttr],
									o =
										(null === (s = this.axis[t].track.el) || void 0 === s
											? void 0
											: s[this.axis[t].offsetSizeAttr]) || 0,
									l = parseInt(this.elStyles[this.axis[t].sizeAttr], 10),
									c = this.contentWrapperEl[this.axis[t].scrollOffsetAttr];
								(c =
									"x" === t &&
									this.isRtl &&
									(null === (i = e.getRtlHelpers()) || void 0 === i
										? void 0
										: i.isScrollOriginAtZero)
										? -c
										: c),
									"x" === t &&
										this.isRtl &&
										(c = (
											null === (r = e.getRtlHelpers()) || void 0 === r
												? void 0
												: r.isScrollingToNegative
										)
											? c
											: -c);
								var d = c / (a - l),
									p = ~~((o - n.size) * d);
								(p = "x" === t && this.isRtl ? -p + (o - n.size) : p),
									(n.el.style.transform =
										"x" === t
											? "translate3d(".concat(p, "px, 0, 0)")
											: "translate3d(0, ".concat(p, "px, 0)"));
							}
						}),
						(e.prototype.toggleTrackVisibility = function (e) {
							void 0 === e && (e = "y");
							var t = this.axis[e].track.el,
								s = this.axis[e].scrollbar.el;
							t &&
								s &&
								this.contentWrapperEl &&
								(this.axis[e].isOverflowing || this.axis[e].forceVisible
									? ((t.style.visibility = "visible"),
									  (this.contentWrapperEl.style[this.axis[e].overflowAttr] =
											"scroll"),
									  this.el.classList.add(
											"".concat(this.classNames.scrollable, "-").concat(e),
									  ))
									: ((t.style.visibility = "hidden"),
									  (this.contentWrapperEl.style[this.axis[e].overflowAttr] =
											"hidden"),
									  this.el.classList.remove(
											"".concat(this.classNames.scrollable, "-").concat(e),
									  )),
								this.axis[e].isOverflowing
									? (s.style.display = "block")
									: (s.style.display = "none"));
						}),
						(e.prototype.showScrollbar = function (e) {
							void 0 === e && (e = "y"),
								this.axis[e].isOverflowing &&
									!this.axis[e].scrollbar.isVisible &&
									(Be(this.axis[e].scrollbar.el, this.classNames.visible),
									(this.axis[e].scrollbar.isVisible = !0));
						}),
						(e.prototype.hideScrollbar = function (e) {
							void 0 === e && (e = "y"),
								this.isDragging ||
									(this.axis[e].isOverflowing &&
										this.axis[e].scrollbar.isVisible &&
										(We(this.axis[e].scrollbar.el, this.classNames.visible),
										(this.axis[e].scrollbar.isVisible = !1)));
						}),
						(e.prototype.hideNativeScrollbar = function () {
							this.offsetEl &&
								((this.offsetEl.style[this.isRtl ? "left" : "right"] =
									this.axis.y.isOverflowing || this.axis.y.forceVisible
										? "-".concat(this.scrollbarWidth, "px")
										: "0px"),
								(this.offsetEl.style.bottom =
									this.axis.x.isOverflowing || this.axis.x.forceVisible
										? "-".concat(this.scrollbarWidth, "px")
										: "0px"));
						}),
						(e.prototype.onMouseMoveForAxis = function (e) {
							void 0 === e && (e = "y");
							var t = this.axis[e];
							t.track.el &&
								t.scrollbar.el &&
								((t.track.rect = t.track.el.getBoundingClientRect()),
								(t.scrollbar.rect = t.scrollbar.el.getBoundingClientRect()),
								this.isWithinBounds(t.track.rect)
									? (this.showScrollbar(e),
									  Be(t.track.el, this.classNames.hover),
									  this.isWithinBounds(t.scrollbar.rect)
											? Be(t.scrollbar.el, this.classNames.hover)
											: We(t.scrollbar.el, this.classNames.hover))
									: (We(t.track.el, this.classNames.hover),
									  this.options.autoHide && this.hideScrollbar(e)));
						}),
						(e.prototype.onMouseLeaveForAxis = function (e) {
							void 0 === e && (e = "y"),
								We(this.axis[e].track.el, this.classNames.hover),
								We(this.axis[e].scrollbar.el, this.classNames.hover),
								this.options.autoHide && this.hideScrollbar(e);
						}),
						(e.prototype.onDragStart = function (e, t) {
							var s;
							void 0 === t && (t = "y"), (this.isDragging = !0);
							var i = De(this.el),
								r = Ie(this.el),
								n = this.axis[t].scrollbar,
								a = "y" === t ? e.pageY : e.pageX;
							(this.axis[t].dragOffset =
								a -
								((null === (s = n.rect) || void 0 === s
									? void 0
									: s[this.axis[t].offsetAttr]) || 0)),
								(this.draggedAxis = t),
								Be(this.el, this.classNames.dragging),
								i.addEventListener("mousemove", this.drag, !0),
								i.addEventListener("mouseup", this.onEndDrag, !0),
								null === this.removePreventClickId
									? (i.addEventListener("click", this.preventClick, !0),
									  i.addEventListener("dblclick", this.preventClick, !0))
									: (r.clearTimeout(this.removePreventClickId),
									  (this.removePreventClickId = null));
						}),
						(e.prototype.onTrackClick = function (e, t) {
							var s,
								i,
								r,
								n,
								a = this;
							void 0 === t && (t = "y");
							var o = this.axis[t];
							if (
								this.options.clickOnTrack &&
								o.scrollbar.el &&
								this.contentWrapperEl
							) {
								e.preventDefault();
								var l = Ie(this.el);
								this.axis[t].scrollbar.rect =
									o.scrollbar.el.getBoundingClientRect();
								var c =
										null !==
											(i =
												null === (s = this.axis[t].scrollbar.rect) ||
												void 0 === s
													? void 0
													: s[this.axis[t].offsetAttr]) && void 0 !== i
											? i
											: 0,
									d = parseInt(
										null !==
											(n =
												null === (r = this.elStyles) || void 0 === r
													? void 0
													: r[this.axis[t].sizeAttr]) && void 0 !== n
											? n
											: "0px",
										10,
									),
									p = this.contentWrapperEl[this.axis[t].scrollOffsetAttr],
									u =
										("y" === t ? this.mouseY - c : this.mouseX - c) < 0
											? -1
											: 1,
									h = -1 === u ? p - d : p + d,
									m = function () {
										a.contentWrapperEl &&
											(-1 === u
												? p > h &&
												  ((p -= 40),
												  (a.contentWrapperEl[a.axis[t].scrollOffsetAttr] = p),
												  l.requestAnimationFrame(m))
												: p < h &&
												  ((p += 40),
												  (a.contentWrapperEl[a.axis[t].scrollOffsetAttr] = p),
												  l.requestAnimationFrame(m)));
									};
								m();
							}
						}),
						(e.prototype.getContentElement = function () {
							return this.contentEl;
						}),
						(e.prototype.getScrollElement = function () {
							return this.contentWrapperEl;
						}),
						(e.prototype.removeListeners = function () {
							var e = Ie(this.el);
							this.el.removeEventListener("mouseenter", this.onMouseEnter),
								this.el.removeEventListener(
									"pointerdown",
									this.onPointerEvent,
									!0,
								),
								this.el.removeEventListener("mousemove", this.onMouseMove),
								this.el.removeEventListener("mouseleave", this.onMouseLeave),
								this.contentWrapperEl &&
									this.contentWrapperEl.removeEventListener(
										"scroll",
										this.onScroll,
									),
								e.removeEventListener("resize", this.onWindowResize),
								this.mutationObserver && this.mutationObserver.disconnect(),
								this.resizeObserver && this.resizeObserver.disconnect(),
								this.onMouseMove.cancel(),
								this.onWindowResize.cancel(),
								this.onStopScrolling.cancel(),
								this.onMouseEntered.cancel();
						}),
						(e.prototype.unMount = function () {
							this.removeListeners();
						}),
						(e.prototype.isWithinBounds = function (e) {
							return (
								this.mouseX >= e.left &&
								this.mouseX <= e.left + e.width &&
								this.mouseY >= e.top &&
								this.mouseY <= e.top + e.height
							);
						}),
						(e.prototype.findChild = function (e, t) {
							var s =
								e.matches ||
								e.webkitMatchesSelector ||
								e.mozMatchesSelector ||
								e.msMatchesSelector;
							return Array.prototype.filter.call(e.children, function (e) {
								return s.call(e, t);
							})[0];
						}),
						(e.rtlHelpers = null),
						(e.defaultOptions = {
							forceVisible: !1,
							clickOnTrack: !0,
							scrollbarMinSize: 25,
							scrollbarMaxSize: 0,
							ariaLabel: "scrollable content",
							tabIndex: 0,
							classNames: {
								contentEl: "simplebar-content",
								contentWrapper: "simplebar-content-wrapper",
								offset: "simplebar-offset",
								mask: "simplebar-mask",
								wrapper: "simplebar-wrapper",
								placeholder: "simplebar-placeholder",
								scrollbar: "simplebar-scrollbar",
								track: "simplebar-track",
								heightAutoObserverWrapperEl:
									"simplebar-height-auto-observer-wrapper",
								heightAutoObserverEl: "simplebar-height-auto-observer",
								visible: "simplebar-visible",
								horizontal: "simplebar-horizontal",
								vertical: "simplebar-vertical",
								hover: "simplebar-hover",
								dragging: "simplebar-dragging",
								scrolling: "simplebar-scrolling",
								scrollable: "simplebar-scrollable",
								mouseEntered: "simplebar-mouse-entered",
							},
							scrollableNode: null,
							contentNode: null,
							autoHide: !0,
						}),
						(e.getOptions = $e),
						(e.helpers = ke),
						e
					);
				})(),
				He = function (e, t) {
					return (
						(He =
							Object.setPrototypeOf ||
							({ __proto__: [] } instanceof Array &&
								function (e, t) {
									e.__proto__ = t;
								}) ||
							function (e, t) {
								for (var s in t)
									Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
							}),
						He(e, t)
					);
				};
			var Ve = qe.helpers,
				Ge = Ve.getOptions,
				Fe = Ve.addClasses,
				Re = Ve.canUseDOM,
				je = (function (e) {
					function t() {
						for (var s = [], i = 0; i < arguments.length; i++)
							s[i] = arguments[i];
						var r = e.apply(this, s) || this;
						return t.instances.set(s[0], r), r;
					}
					return (
						(function (e, t) {
							if ("function" != typeof t && null !== t)
								throw new TypeError(
									"Class extends value " +
										String(t) +
										" is not a constructor or null",
								);
							function s() {
								this.constructor = e;
							}
							He(e, t),
								(e.prototype =
									null === t
										? Object.create(t)
										: ((s.prototype = t.prototype), new s()));
						})(t, e),
						(t.initDOMLoadedElements = function () {
							document.removeEventListener(
								"DOMContentLoaded",
								this.initDOMLoadedElements,
							),
								window.removeEventListener("load", this.initDOMLoadedElements),
								Array.prototype.forEach.call(
									document.querySelectorAll("[data-simplebar]"),
									function (e) {
										"init" === e.getAttribute("data-simplebar") ||
											t.instances.has(e) ||
											new t(e, Ge(e.attributes));
									},
								);
						}),
						(t.removeObserver = function () {
							var e;
							null === (e = t.globalObserver) || void 0 === e || e.disconnect();
						}),
						(t.prototype.initDOM = function () {
							var e,
								t,
								s,
								i = this;
							if (
								!Array.prototype.filter.call(this.el.children, function (e) {
									return e.classList.contains(i.classNames.wrapper);
								}).length
							) {
								for (
									this.wrapperEl = document.createElement("div"),
										this.contentWrapperEl = document.createElement("div"),
										this.offsetEl = document.createElement("div"),
										this.maskEl = document.createElement("div"),
										this.contentEl = document.createElement("div"),
										this.placeholderEl = document.createElement("div"),
										this.heightAutoObserverWrapperEl =
											document.createElement("div"),
										this.heightAutoObserverEl = document.createElement("div"),
										Fe(this.wrapperEl, this.classNames.wrapper),
										Fe(this.contentWrapperEl, this.classNames.contentWrapper),
										Fe(this.offsetEl, this.classNames.offset),
										Fe(this.maskEl, this.classNames.mask),
										Fe(this.contentEl, this.classNames.contentEl),
										Fe(this.placeholderEl, this.classNames.placeholder),
										Fe(
											this.heightAutoObserverWrapperEl,
											this.classNames.heightAutoObserverWrapperEl,
										),
										Fe(
											this.heightAutoObserverEl,
											this.classNames.heightAutoObserverEl,
										);
									this.el.firstChild;

								)
									this.contentEl.appendChild(this.el.firstChild);
								this.contentWrapperEl.appendChild(this.contentEl),
									this.offsetEl.appendChild(this.contentWrapperEl),
									this.maskEl.appendChild(this.offsetEl),
									this.heightAutoObserverWrapperEl.appendChild(
										this.heightAutoObserverEl,
									),
									this.wrapperEl.appendChild(this.heightAutoObserverWrapperEl),
									this.wrapperEl.appendChild(this.maskEl),
									this.wrapperEl.appendChild(this.placeholderEl),
									this.el.appendChild(this.wrapperEl),
									null === (e = this.contentWrapperEl) ||
										void 0 === e ||
										e.setAttribute(
											"tabindex",
											this.options.tabIndex.toString(),
										),
									null === (t = this.contentWrapperEl) ||
										void 0 === t ||
										t.setAttribute("role", "region"),
									null === (s = this.contentWrapperEl) ||
										void 0 === s ||
										s.setAttribute("aria-label", this.options.ariaLabel);
							}
							if (!this.axis.x.track.el || !this.axis.y.track.el) {
								var r = document.createElement("div"),
									n = document.createElement("div");
								Fe(r, this.classNames.track),
									Fe(n, this.classNames.scrollbar),
									r.appendChild(n),
									(this.axis.x.track.el = r.cloneNode(!0)),
									Fe(this.axis.x.track.el, this.classNames.horizontal),
									(this.axis.y.track.el = r.cloneNode(!0)),
									Fe(this.axis.y.track.el, this.classNames.vertical),
									this.el.appendChild(this.axis.x.track.el),
									this.el.appendChild(this.axis.y.track.el);
							}
							qe.prototype.initDOM.call(this),
								this.el.setAttribute("data-simplebar", "init");
						}),
						(t.prototype.unMount = function () {
							qe.prototype.unMount.call(this), t.instances.delete(this.el);
						}),
						(t.initHtmlApi = function () {
							(this.initDOMLoadedElements =
								this.initDOMLoadedElements.bind(this)),
								"undefined" != typeof MutationObserver &&
									((this.globalObserver = new MutationObserver(
										t.handleMutations,
									)),
									this.globalObserver.observe(document, {
										childList: !0,
										subtree: !0,
									})),
								"complete" === document.readyState ||
								("loading" !== document.readyState &&
									!document.documentElement.doScroll)
									? window.setTimeout(this.initDOMLoadedElements)
									: (document.addEventListener(
											"DOMContentLoaded",
											this.initDOMLoadedElements,
									  ),
									  window.addEventListener(
											"load",
											this.initDOMLoadedElements,
									  ));
						}),
						(t.handleMutations = function (e) {
							e.forEach(function (e) {
								e.addedNodes.forEach(function (e) {
									1 === e.nodeType &&
										(e.hasAttribute("data-simplebar")
											? !t.instances.has(e) &&
											  document.documentElement.contains(e) &&
											  new t(e, Ge(e.attributes))
											: e
													.querySelectorAll("[data-simplebar]")
													.forEach(function (e) {
														"init" !== e.getAttribute("data-simplebar") &&
															!t.instances.has(e) &&
															document.documentElement.contains(e) &&
															new t(e, Ge(e.attributes));
													}));
								}),
									e.removedNodes.forEach(function (e) {
										var s;
										1 === e.nodeType &&
											("init" === e.getAttribute("data-simplebar")
												? !document.documentElement.contains(e) &&
												  (null === (s = t.instances.get(e)) ||
														void 0 === s ||
														s.unMount())
												: Array.prototype.forEach.call(
														e.querySelectorAll('[data-simplebar="init"]'),
														function (e) {
															var s;
															!document.documentElement.contains(e) &&
																(null === (s = t.instances.get(e)) ||
																	void 0 === s ||
																	s.unMount());
														},
												  ));
									});
							});
						}),
						(t.instances = new WeakMap()),
						t
					);
				})(qe);
			Re && je.initHtmlApi(),
				document.querySelectorAll("[data-simplebar]").length &&
					document.querySelectorAll("[data-simplebar]").forEach((e) => {
						new je(e, { autoHide: !1 });
					});
			new (s(144))({
				elements_selector: "[data-src],[data-srcset]",
				class_loaded: "_lazy-loaded",
				use_native: !0,
			});
			window.addEventListener("load", () => {
				e.watcher.onDOMContentLoaded();
			}),
				(e.watcher = new (class {
					constructor(e) {
						(this.config = Object.assign({ logging: !0 }, e)),
							this.observer,
							!document.documentElement.classList.contains("watcher") &&
								this.scrollWatcherRun();
					}
					checkVisibleElements() {
						document.querySelectorAll("[data-watch]").forEach((e) => {
							const t = e.getBoundingClientRect();
							t.top < window.innerHeight &&
								t.bottom > 0 &&
								!e.classList.contains("_watcher-view") &&
								this.scrollWatcherCallback(
									{ isIntersecting: !0, target: e },
									this.observer,
								);
						});
					}
					onDOMContentLoaded() {
						this.scrollWatcherRun(),
							setTimeout(() => this.checkVisibleElements(), 200),
							setTimeout(() => this.checkVisibleElements(), 500);
					}
					scrollWatcherUpdate() {
						this.scrollWatcherRun();
					}
					scrollWatcherRun() {
						document.documentElement.classList.add("watcher"),
							this.scrollWatcherConstructor(
								document.querySelectorAll("[data-watch]"),
							);
					}
					scrollWatcherConstructor(e) {
						if (e.length) {
							this.scrollWatcherLogging(
								`,   ' (${e.length})...`,
							),
								p(
									Array.from(e).map(function (e) {
										if (
											"navigator" === e.dataset.watch &&
											!e.dataset.watchThreshold
										) {
											let t;
											e.clientHeight > 2
												? ((t = window.innerHeight / 2 / (e.clientHeight - 1)),
												  t > 1 && (t = 1))
												: (t = 1),
												e.setAttribute("data-watch-threshold", t.toFixed(2));
										}
										return `${
											e.dataset.watchRoot ? e.dataset.watchRoot : null
										}|${e.dataset.watchMargin ? e.dataset.watchMargin : "0px"}|${e.dataset.watchThreshold ? e.dataset.watchThreshold : 0}`;
									}),
								).forEach((t) => {
									let s = t.split("|"),
										i = { root: s[0], margin: s[1], threshold: s[2] },
										r = Array.from(e).filter(function (e) {
											let t = e.dataset.watchRoot ? e.dataset.watchRoot : null,
												s = e.dataset.watchMargin
													? e.dataset.watchMargin
													: "0px",
												r = e.dataset.watchThreshold
													? e.dataset.watchThreshold
													: 0;
											if (
												String(t) === i.root &&
												String(s) === i.margin &&
												String(r) === i.threshold
											)
												return e;
										}),
										n = this.getScrollWatcherConfig(i);
									this.scrollWatcherInit(r, n);
								});
						} else
							this.scrollWatcherLogging(
								",  '  . ZzzZZzz",
							);
					}
					getScrollWatcherConfig(e) {
						let t = {};
						if (
							(document.querySelector(e.root)
								? (t.root = document.querySelector(e.root))
								: "null" !== e.root &&
								  this.scrollWatcherLogging(
										`...  ' ${e.root}   `,
								  ),
							(t.rootMargin = e.margin),
							!(e.margin.indexOf("px") < 0 && e.margin.indexOf("%") < 0))
						) {
							if ("prx" === e.threshold) {
								e.threshold = [];
								for (let t = 0; t <= 1; t += 0.005) e.threshold.push(t);
							} else e.threshold = e.threshold.split(",");
							return (t.threshold = e.threshold), t;
						}
						this.scrollWatcherLogging(
							",  data-watch-margin    PX  %",
						);
					}
					scrollWatcherCreate(e) {
						console.log(e),
							(this.observer = new IntersectionObserver((e, t) => {
								e.forEach((e) => {
									this.scrollWatcherCallback(e, t);
								});
							}, e));
					}
					scrollWatcherInit(e, t) {
						this.scrollWatcherCreate(t),
							e.forEach((e) => this.observer.observe(e));
					}
					scrollWatcherIntersecting(e, t) {
						e.isIntersecting
							? t.classList.contains("_watcher-view") ||
							  (t._watcherTimeout = setTimeout(() => {
									t.classList.add("_watcher-view"),
										this.scrollWatcherLogging(
											`  ${t.classList},   _watcher-view`,
										);
							  }, 100))
							: (t._watcherTimeout && clearTimeout(t._watcherTimeout),
							  t.classList.contains("_watcher-view") &&
									(t.classList.remove("_watcher-view"),
									this.scrollWatcherLogging(
										`   ${t.classList},   _watcher-view`,
									)));
					}
					scrollWatcherOff(e, t) {
						t.unobserve(e),
							this.scrollWatcherLogging(`    ${e.classList}`);
					}
					scrollWatcherLogging(e) {
						this.config.logging && d(`[]: ${e}`);
					}
					scrollWatcherCallback(e, t) {
						const s = e.target;
						this.scrollWatcherIntersecting(e, s),
							s.hasAttribute("data-watch-once") &&
								e.isIntersecting &&
								this.scrollWatcherOff(s, t),
							document.dispatchEvent(
								new CustomEvent("watcherCallback", { detail: { entry: e } }),
							);
					}
				})({}));
			let Ye = (e, t = !1, s = 500, i = 0) => {
					const r = document.querySelector(e);
					if (r) {
						let n = "",
							a = 0;
						if (t) {
							n = "header.header";
							const e = document.querySelector(n);
							e.classList.contains("_header-scroll")
								? (a = e.offsetHeight)
								: ((e.style.cssText = "transition-duration: 0s;"),
								  e.classList.add("_header-scroll"),
								  (a = e.offsetHeight),
								  e.classList.remove("_header-scroll"),
								  setTimeout(() => {
										e.style.cssText = "";
								  }, 0));
						}
						let o = {
							speedAsDuration: !0,
							speed: s,
							header: n,
							offset: i,
							easing: "easeOutQuad",
						};
						if (
							(document.documentElement.classList.contains("menu-open") && c(),
							"undefined" != typeof SmoothScroll)
						)
							new SmoothScroll().animateScroll(r, "", o);
						else {
							let e = r.getBoundingClientRect().top + scrollY;
							(e = a ? e - a : e),
								(e = i ? e - i : e),
								window.scrollTo({ top: e, behavior: "smooth" });
						}
						d(`[gotoBlock]: ...  ${e}`);
					} else d(`[gotoBlock]: ...     : ${e}`);
				},
				Xe = !1;
			document.addEventListener("DOMContentLoaded", function () {
				const e = document.createElement("style");
				(e.textContent =
					"\n\t\thtml {\n\t\t\tscroll-behavior: smooth;\n\t\t}\n\t\t\n\t\t/*  WebKit  */\n\t\thtml::-webkit-scrollbar {\n\t\t\twidth: 8px;\n\t\t}\n\t\t\n\t\thtml::-webkit-scrollbar-track {\n\t\t\tbackground: rgba(0,0,0,0.1);\n\t\t}\n\t\t\n\t\thtml::-webkit-scrollbar-thumb {\n\t\t\tbackground: rgba(0,0,0,0.3);\n\t\t\tborder-radius: 4px;\n\t\t\ttransition: background 0.3s ease;\n\t\t}\n\t\t\n\t\thtml::-webkit-scrollbar-thumb:hover {\n\t\t\tbackground: rgba(0,0,0,0.5);\n\t\t}\n\t"),
					document.head.appendChild(e),
					t.any() &&
						((document.body.style.webkitOverflowScrolling = "touch"),
						(document.documentElement.style.webkitOverflowScrolling = "touch"));
				let s,
					i = !1;
				window.addEventListener(
					"scroll",
					function () {
						i || (document.body.classList.add("is-scrolling"), (i = !0)),
							clearTimeout(s),
							(s = setTimeout(function () {
								document.body.classList.remove("is-scrolling"), (i = !1);
							}, 150));
					},
					{ passive: !0 },
				);
			}),
				setTimeout(() => {
					if (Xe) {
						let e = new Event("windowScroll");
						window.addEventListener("scroll", function (t) {
							document.dispatchEvent(e);
						});
					}
				}, 0);
			new (class {
				constructor(e) {
					this.type = e;
				}
				init() {
					(this.bjects = []),
						(this.daClassname = "_dynamic_adapt_"),
						(this.nodes = [...document.querySelectorAll("[data-da]")]),
						this.nodes.forEach((e) => {
							const t = e.dataset.da.trim().split(","),
								s = {};
							(s.element = e),
								(s.parent = e.parentNode),
								(s.destination = document.querySelector(`${t[0].trim()}`)),
								(s.breakpoint = t[1] ? t[1].trim() : "767.98"),
								(s.place = t[2] ? t[2].trim() : "last"),
								(s.index = this.indexInParent(s.parent, s.element)),
								this.bjects.push(s);
						}),
						this.arraySort(this.bjects),
						(this.mediaQueries = this.bjects
							.map(
								({ breakpoint: e }) => `(${this.type}-width: ${e / 16}em),${e}`,
							)
							.filter((e, t, s) => s.indexOf(e) === t)),
						this.mediaQueries.forEach((e) => {
							const t = e.split(","),
								s = window.matchMedia(t[0]),
								i = t[1],
								r = this.bjects.filter(({ breakpoint: e }) => e === i);
							s.addEventListener("change", () => {
								this.mediaHandler(s, r);
							}),
								this.mediaHandler(s, r);
						});
				}
				mediaHandler(e, t) {
					e.matches
						? t.forEach((e) => {
								this.moveTo(e.place, e.element, e.destination);
						  })
						: t.forEach(({ parent: e, element: t, index: s }) => {
								t.classList.contains(this.daClassname) &&
									this.moveBack(e, t, s);
						  });
				}
				moveTo(e, t, s) {
					t.classList.add(this.daClassname),
						"last" === e || e >= s.children.length
							? s.append(t)
							: "first" !== e
							? s.children[e].before(t)
							: s.prepend(t);
				}
				moveBack(e, t, s) {
					t.classList.remove(this.daClassname),
						void 0 !== e.children[s] ? e.children[s].before(t) : e.append(t);
				}
				indexInParent(e, t) {
					return [...e.children].indexOf(t);
				}
				arraySort(e) {
					"min" === this.type
						? e.sort((e, t) =>
								e.breakpoint === t.breakpoint
									? e.place === t.place
										? 0
										: "first" === e.place || "last" === t.place
										? -1
										: "last" === e.place || "first" === t.place
										? 1
										: 0
									: e.breakpoint - t.breakpoint,
						  )
						: e.sort((e, t) =>
								e.breakpoint === t.breakpoint
									? e.place === t.place
										? 0
										: "first" === e.place || "last" === t.place
										? 1
										: "last" === e.place || "first" === t.place
										? -1
										: 0
									: t.breakpoint - e.breakpoint,
						  );
				}
			})("max").init();
			(e.popup = new (class {
				constructor(e) {
					let t = {
						logging: !0,
						init: !0,
						attributeOpenButton: "data-popup",
						attributeCloseButton: "data-close",
						fixElementSelector: "[data-lp]",
						youtubeAttribute: "data-popup-youtube",
						youtubePlaceAttribute: "data-popup-youtube-place",
						setAutoplayYoutube: !0,
						classes: {
							popup: "popup",
							popupContent: "popup__content",
							popupActive: "popup_show",
							bodyActive: "popup-show",
						},
						focusCatch: !0,
						closeEsc: !0,
						bodyLock: !0,
						hashSettings: { location: !0, goHash: !0 },
						on: {
							beforeOpen: function () {},
							afterOpen: function () {},
							beforeClose: function () {},
							afterClose: function () {},
						},
					};
					this.youTubeCode,
						(this.isOpen = !1),
						(this.targetOpen = { selector: !1, element: !1 }),
						(this.previousOpen = { selector: !1, element: !1 }),
						(this.lastClosed = { selector: !1, element: !1 }),
						(this._dataValue = !1),
						(this.hash = !1),
						(this._reopen = !1),
						(this._selectorOpen = !1),
						(this.lastFocusEl = !1),
						(this._focusEl = [
							"a[href]",
							'input:not([disabled]):not([type="hidden"]):not([aria-hidden])',
							"button:not([disabled]):not([aria-hidden])",
							"select:not([disabled]):not([aria-hidden])",
							"textarea:not([disabled]):not([aria-hidden])",
							"area[href]",
							"iframe",
							"object",
							"embed",
							"[contenteditable]",
							'[tabindex]:not([tabindex^="-"])',
						]),
						(this.options = {
							...t,
							...e,
							classes: { ...t.classes, ...e?.classes },
							hashSettings: { ...t.hashSettings, ...e?.hashSettings },
							on: { ...t.on, ...e?.on },
						}),
						(this.bodyLock = !1),
						console.log(
							`[POPUP DEBUG]:   , options.init: ${this.options.init}`,
						),
						this.options.init && this.initPopups();
				}
				initPopups() {
					console.log("[POPUP DEBUG]:  Popup "),
						this.popupLogging(" Popup"),
						console.log(`[POPUP DEBUG]: bodyLockStatus: ${a}`),
						this.popupLogging(`bodyLockStatus: ${a}`),
						this.eventsPopup(),
						console.log("[POPUP DEBUG]:  Popup ");
				}
				eventsPopup() {
					this.popupLogging("  Popup"),
						document.addEventListener(
							"click",
							function (e) {
								console.log(
									`[POPUP DEBUG]:  , target: ${e.target.tagName}.${e.target.className}`,
								);
								const t = e.target.closest(
									`[${this.options.attributeOpenButton}]`,
								);
								if (t)
									return (
										this.popupLogging(
											`   : ${t.getAttribute(
												this.options.attributeOpenButton,
											)}`,
										),
										e.preventDefault(),
										(this._dataValue = t.getAttribute(
											this.options.attributeOpenButton,
										)
											? t.getAttribute(this.options.attributeOpenButton)
											: "error"),
										(this.youTubeCode = t.getAttribute(
											this.options.youtubeAttribute,
										)
											? t.getAttribute(this.options.youtubeAttribute)
											: null),
										"error" !== this._dataValue
											? (this.isOpen || (this.lastFocusEl = t),
											  (this.targetOpen.selector = `${this._dataValue}`),
											  (this._selectorOpen = !0),
											  void this.open())
											: void this.popupLogging(
													`:     ${t.classList}`,
											  )
									);
								const s = e.target.closest(
									`[${this.options.attributeCloseButton}]`,
								);
								return s ||
									(!e.target.closest(`.${this.options.classes.popupContent}`) &&
										this.isOpen)
									? (this.popupLogging(
											" : " +
												(s ? " data-close" : "  popup__content"),
									  ),
									  e.preventDefault(),
									  void this.close())
									: void 0;
							}.bind(this),
						),
						document.addEventListener(
							"keydown",
							function (e) {
								if (
									this.options.closeEsc &&
									27 == e.which &&
									"Escape" === e.code &&
									this.isOpen
								)
									return (
										this.popupLogging("   ESC"),
										e.preventDefault(),
										void this.close()
									);
								this.options.focusCatch &&
									9 == e.which &&
									this.isOpen &&
									this._focusCatch(e);
							}.bind(this),
						),
						this.options.hashSettings.goHash &&
							(window.addEventListener(
								"hashchange",
								function () {
									window.location.hash
										? (this.popupLogging(
												` : ${window.location.hash}`,
										  ),
										  this._openToHash())
										: (this.popupLogging(
												` ,  : ${this.targetOpen.selector}`,
										  ),
										  this.close(this.targetOpen.selector));
								}.bind(this),
							),
							window.addEventListener(
								"load",
								function () {
									window.location.hash &&
										(this.popupLogging(
											`   : ${window.location.hash}`,
										),
										this._openToHash());
								}.bind(this),
							));
				}
				open(e) {
					if (
						(this.popupLogging(
							` open   selectorValue: ${
								e || this.targetOpen.selector
							}`,
						),
						a)
					)
						if (
							((this.bodyLock = !(
								!document.documentElement.classList.contains("lock") ||
								this.isOpen
							)),
							e &&
								"string" == typeof e &&
								"" !== e.trim() &&
								((this.targetOpen.selector = e), (this._selectorOpen = !0)),
							this.isOpen && ((this._reopen = !0), this.close()),
							this._selectorOpen ||
								(this.targetOpen.selector = this.lastClosed.selector),
							this._reopen ||
								(this.previousActiveElement = document.activeElement),
							(this.targetOpen.element = document.querySelector(
								this.targetOpen.selector,
							)),
							this.popupLogging(
								`targetOpen.element: ${
									this.targetOpen.element
										? this.targetOpen.element.id
										: " "
								}`,
							),
							this.targetOpen.element)
						) {
							if (this.youTubeCode) {
								const e = `https://www.youtube.com/embed/${this.youTubeCode}?rel=0&showinfo=0&autoplay=1`,
									t = document.createElement("iframe");
								t.setAttribute("allowfullscreen", "");
								const s = this.options.setAutoplayYoutube ? "autoplay;" : "";
								t.setAttribute("allow", `${s}; encrypted-media`),
									t.setAttribute("src", e),
									this.targetOpen.element.querySelector(
										`[${this.options.youtubePlaceAttribute}]`,
									) ||
										this.targetOpen.element
											.querySelector(".popup__text")
											?.setAttribute(this.options.youtubePlaceAttribute, ""),
									this.targetOpen.element
										.querySelector(`[${this.options.youtubePlaceAttribute}]`)
										?.appendChild(t),
									this.popupLogging(` YouTube iframe: ${e}`);
							}
							const e = this.targetOpen.element.querySelectorAll("video");
							e.length > 0 &&
								(this.popupLogging(
									` ${e.length}   `,
								),
								e.forEach((e) => {
									e.play().catch(() => {
										this.popupLogging(
											"   (   )",
										);
									});
								})),
								this.options.hashSettings.location &&
									(this._getHash(), this._setHash()),
								this.options.on.beforeOpen(this),
								document.dispatchEvent(
									new CustomEvent("beforePopupOpen", {
										detail: { popup: this },
									}),
								),
								this.targetOpen.element.classList.add(
									this.options.classes.popupActive,
								),
								document.documentElement.classList.add(
									this.options.classes.bodyActive,
								),
								this._reopen ? (this._reopen = !1) : !this.bodyLock && l(),
								this.targetOpen.element.setAttribute("aria-hidden", "false"),
								(this.previousOpen.selector = this.targetOpen.selector),
								(this.previousOpen.element = this.targetOpen.element),
								(this._selectorOpen = !1),
								(this.isOpen = !0),
								this.popupLogging(
									` , isOpen: ${this.isOpen}, selector: ${this.targetOpen.selector}`,
								),
								setTimeout(() => {
									this._focusTrap();
								}, 50),
								this.options.on.afterOpen(this),
								document.dispatchEvent(
									new CustomEvent("afterPopupOpen", {
										detail: { popup: this },
									}),
								);
						} else
							this.popupLogging(
								`:  ${this.targetOpen.selector}  `,
							);
					else this.popupLogging(`: bodyLockStatus = ${a}`);
				}
				close(e) {
					if (
						(this.popupLogging(
							` close   selectorValue: ${e || ""}`,
						),
						e &&
							"string" == typeof e &&
							"" !== e.trim() &&
							((this.previousOpen.selector = e),
							this.popupLogging(
								` previousOpen.selector: ${this.previousOpen.selector}`,
							)),
						this.isOpen && a)
					) {
						if (
							(this.options.on.beforeClose(this),
							document.dispatchEvent(
								new CustomEvent("beforePopupClose", {
									detail: { popup: this },
								}),
							),
							this._stopAllVideos(),
							this.youTubeCode)
						) {
							const e = this.targetOpen.element?.querySelector(
								`[${this.options.youtubePlaceAttribute}]`,
							);
							e &&
								((e.innerHTML = ""),
								this.popupLogging(" YouTube "));
						}
						this.previousOpen.element &&
							(this.previousOpen.element.classList.remove(
								this.options.classes.popupActive,
							),
							this.previousOpen.element.setAttribute("aria-hidden", "true"),
							this.popupLogging(
								`  ${this.options.classes.popupActive}  ${
									this.previousOpen.element.id ||
									this.previousOpen.element.className
								}`,
							)),
							this._reopen ||
								(document.documentElement.classList.remove(
									this.options.classes.bodyActive,
								),
								!this.bodyLock && o(),
								(this.isOpen = !1),
								this.popupLogging(
									`isOpen   ${this.isOpen}, bodyUnlock `,
								)),
							this._removeHash(),
							this._selectorOpen &&
								((this.lastClosed.selector = this.previousOpen.selector),
								(this.lastClosed.element = this.previousOpen.element),
								this.popupLogging(
									` lastClosed: ${this.lastClosed.selector}`,
								)),
							this.options.on.afterClose(this),
							document.dispatchEvent(
								new CustomEvent("afterPopupClose", { detail: { popup: this } }),
							),
							setTimeout(() => {
								this._focusTrap();
							}, 50),
							this.popupLogging(" ");
					} else
						this.popupLogging(
							`  close: isOpen=${this.isOpen}, bodyLockStatus=${a}`,
						);
				}
				_stopAllVideos() {
					if (!this.targetOpen.element) return;
					this.popupLogging(
						`   : ${this.targetOpen.selector}`,
					);
					const e = this.targetOpen.element.querySelectorAll("video");
					e.forEach((e) => {
						e.paused || (e.pause(), (e.currentTime = 0));
					});
					const t = this.targetOpen.element.querySelectorAll(
						'iframe[src*="youtube"]',
					);
					t.forEach((e) => {
						try {
							e.contentWindow?.postMessage(
								'{"event":"command","func":"pauseVideo","args":""}',
								"*",
							);
						} catch (e) {}
					}),
						this.popupLogging(
							` ${e.length}   ${t.length} YouTube iframe`,
						);
				}
				_getHash() {
					this.options.hashSettings.location &&
						((this.hash = this.targetOpen.selector.includes("#")
							? this.targetOpen.selector
							: this.targetOpen.selector.replace(".", "#")),
						this.popupLogging(` : ${this.hash}`));
				}
				_openToHash() {
					let e = document.querySelector(
						`.${window.location.hash.replace("#", "")}`,
					)
						? `.${window.location.hash.replace("#", "")}`
						: document.querySelector(`${window.location.hash}`)
						? `${window.location.hash}`
						: null;
					const t = document.querySelector(
						`[${this.options.attributeOpenButton}="${e}"]`,
					)
						? document.querySelector(
								`[${this.options.attributeOpenButton}="${e}"]`,
						  )
						: document.querySelector(
								`[${this.options.attributeOpenButton}="${e.replace(
									".",
									"#",
								)}"]`,
						  );
					(this.youTubeCode =
						t?.getAttribute(this.options.youtubeAttribute) || null),
						this.popupLogging(
							`  : ${e}, : ${
								t
									? t.getAttribute(this.options.attributeOpenButton)
									: " "
							}`,
						),
						t && e && this.open(e);
				}
				_setHash() {
					this.popupLogging(` : ${this.hash}`),
						history.pushState("", "", this.hash);
				}
				_removeHash() {
					this.popupLogging(" "),
						history.pushState("", "", window.location.href.split("#")[0]);
				}
				_focusCatch(e) {
					const t = this.targetOpen.element.querySelectorAll(this._focusEl),
						s = Array.prototype.slice.call(t),
						i = s.indexOf(document.activeElement);
					e.shiftKey &&
						0 === i &&
						(s[s.length - 1].focus(), e.preventDefault()),
						e.shiftKey ||
							i !== s.length - 1 ||
							(s[0].focus(), e.preventDefault());
				}
				_focusTrap() {
					const e = this.previousOpen.element.querySelectorAll(this._focusEl);
					!this.isOpen && this.lastFocusEl
						? this.lastFocusEl.focus()
						: e.length > 0 && e[0].focus();
				}
				popupLogging(e) {
					console.log(`[POPUP DEBUG]: ${e}`),
						this.options.logging && d(`[]: ${e}`);
				}
			})({})),
				window.addEventListener("load", function () {
					document.body.classList.remove("load");
				});
			var Ue = new Date().getFullYear();
			function Ke() {
				const e = document.querySelectorAll(".reviews__slide"),
					t = document.querySelector(".reviews__more");
				if ((e.forEach((e) => e.classList.remove("is-hidden")), t)) {
					t.classList.remove("disabled"), (t.disabled = !1);
					const e = t.cloneNode(!0);
					t.parentNode.replaceChild(e, t);
				}
				if (window.innerWidth <= 1023.98 || e.length <= 8) return;
				e.forEach((e, t) => {
					t >= 8 && e.classList.add("is-hidden");
				});
				let s = 8;
				document
					.querySelector(".reviews__more")
					?.addEventListener("click", (t) => {
						t.preventDefault();
						if (
							(Array.from(e)
								.slice(s, s + 4)
								.forEach((e) => {
									e.classList.remove("is-hidden"), n(e);
								}),
							(s += 4),
							s >= e.length)
						) {
							const e = document.querySelector(".reviews__more");
							e && ((e.disabled = !0), e.classList.add("disabled"));
						}
					});
			}
			document.querySelectorAll(".footer__year").forEach(function (e) {
				e.innerText = Ue;
			}),
				document.addEventListener("touchstart", function () {}, !0),
				window.addEventListener("load", Ke),
				window.addEventListener("resize", Ke),
				(window.scrollHintManager = {
					isActive: !1,
					currentSlider: null,
					hasBeenShown: !1,
					show: function (e) {
						this.isActive ||
							!e ||
							this.hasBeenShown ||
							(e.classList.add("_scrolling"),
							(this.isActive = !0),
							(this.currentSlider = e),
							(this.hasBeenShown = !0));
					},
					hide: function () {
						this.isActive &&
							this.currentSlider &&
							(this.currentSlider.classList.remove("_scrolling"),
							(this.isActive = !1),
							(this.currentSlider = null));
					},
					hideAll: function () {
						document
							.querySelectorAll(".trading-indicators__swiper._scrolling")
							.forEach((e) => e.classList.remove("_scrolling")),
							(this.isActive = !1),
							(this.currentSlider = null);
					},
				}),
				document.addEventListener("DOMContentLoaded", function () {
					const e = document.querySelectorAll(".trading-indicators__swiper");
					if (!e.length || window.innerWidth >= 1024) return;
					if (window.scrollHintManager.hasBeenShown) return;
					let t = !1,
						s = null,
						i = null,
						r = null;
					(s = new IntersectionObserver(
						(s) => {
							const i = s
								.sort(
									(t, s) =>
										Array.from(e).indexOf(t.target) -
										Array.from(e).indexOf(s.target),
								)
								.find((e) => e.isIntersecting);
							!i ||
								t ||
								window.scrollHintManager.hasBeenShown ||
								setTimeout(() => {
									t ||
										window.scrollHintManager.hasBeenShown ||
										(window.scrollHintManager.show(i.target),
										(t = !0),
										(r = i.target));
								}, 800);
						},
						{ threshold: 0.3, rootMargin: "0px 0px -10% 0px" },
					)),
						e.forEach((e) => {
							s.observe(e);
						}),
						(i = (e) => {
							e.target.closest(".trading-indicators__swiper") &&
								t &&
								r &&
								(window.scrollHintManager.hide(),
								(t = !1),
								(r = null),
								s && (s.disconnect(), (s = null)),
								i &&
									(document.removeEventListener("touchstart", i), (i = null)));
						}),
						document.addEventListener("touchstart", i, { passive: !0 });
				}),
				(window.FLS = !0),
				document.documentElement.classList.contains("loading") ||
					(document.addEventListener("DOMContentLoaded", function () {
						setTimeout(function () {
							document.documentElement.classList.add("loaded");
						}, 100);
					}),
					window.addEventListener("load", function () {
						document.documentElement.classList.contains("loaded") ||
							document.documentElement.classList.add("loaded");
					})),
				document.querySelector(".icon-menu") &&
					document.addEventListener("click", function (e) {
						a &&
							e.target.closest(".icon-menu") &&
							(((e = 500) => {
								document.documentElement.classList.contains("lock")
									? o(e)
									: l(e);
							})(),
							document.documentElement.classList.toggle("menu-open"));
					}),
				(function () {
					const e = document.querySelectorAll("[data-spollers]");
					if (e.length > 0) {
						document.addEventListener("click", o);
						const t = Array.from(e).filter(function (e, t, s) {
							return !e.dataset.spollers.split(",")[0];
						});
						t.length && i(t);
						let s = u(e, "spollers");
						function i(e, t = !1) {
							e.forEach((e) => {
								(e = t ? e.item : e),
									t.matches || !t
										? (e.classList.add("_spoller-init"), a(e))
										: (e.classList.remove("_spoller-init"), a(e, !1));
							});
						}
						function a(e, t = !0) {
							let s = e.querySelectorAll("details");
							s.length &&
								s.forEach((e) => {
									let s = e.querySelector("summary");
									t
										? (s.removeAttribute("tabindex"),
										  e.hasAttribute("data-open")
												? (s.classList.add("_spoller-active"), (e.open = !0))
												: ((e.open = !1), (s.nextElementSibling.hidden = !0)))
										: (s.setAttribute("tabindex", "-1"),
										  s.classList.remove("_spoller-active"),
										  (e.open = !0),
										  (s.nextElementSibling.hidden = !1));
								});
						}
						function o(e) {
							const t = e.target;
							if (
								t.closest("summary") &&
								t.closest("[data-spollers]") &&
								(e.preventDefault(),
								t
									.closest("[data-spollers]")
									.classList.contains("_spoller-init"))
							) {
								const e = t.closest("summary"),
									s = e.closest("details"),
									i = e.closest("[data-spollers]"),
									a = i.hasAttribute("data-one-spoller"),
									o = s.hasAttribute("data-spoller-scroll"),
									c = i.dataset.spollersSpeed
										? parseInt(i.dataset.spollersSpeed)
										: 500;
								if (
									!i.querySelectorAll("._slide").length &&
									(a && !s.open && l(i),
									s.open
										? setTimeout(() => {
												s.open = !1;
										  }, c)
										: (s.open = !0),
									e.classList.toggle("_spoller-active"),
									((e, t = 500) => {
										e.hidden ? n(e, t) : r(e, t);
									})(e.nextElementSibling, c),
									o && e.classList.contains("_spoller-active"))
								) {
									const e = s.dataset.spollerScroll,
										t = +e ? +e : 0,
										i = s.hasAttribute("data-spoller-scroll-noheader")
											? document.querySelector(".header").offsetHeight
											: 0;
									window.scrollTo({
										top: s.offsetTop - (t + i),
										behavior: "smooth",
									});
								}
							}
							if (!t.closest("[data-spollers]")) {
								const e = document.querySelectorAll("[data-spoller-close]");
								e.length &&
									e.forEach((e) => {
										const t = e.closest("[data-spollers]"),
											s = e.parentNode;
										if (t.classList.contains("_spoller-init")) {
											const i = t.dataset.spollersSpeed
												? parseInt(t.dataset.spollersSpeed)
												: 500;
											e.classList.remove("_spoller-active"),
												r(e.nextElementSibling, i),
												setTimeout(() => {
													s.open = !1;
												}, i);
										}
									});
							}
						}
						function l(e) {
							const t = e.querySelector("details[open]");
							if (t && !e.querySelectorAll("._slide").length) {
								const s = t.querySelector("summary"),
									i = e.dataset.spollersSpeed
										? parseInt(e.dataset.spollersSpeed)
										: 500;
								s.classList.remove("_spoller-active"),
									r(s.nextElementSibling, i),
									setTimeout(() => {
										t.open = !1;
									}, i);
							}
						}
						s &&
							s.length &&
							s.forEach((e) => {
								e.matchMedia.addEventListener("change", function () {
									i(e.itemsArray, e.matchMedia);
								}),
									i(e.itemsArray, e.matchMedia);
							});
					}
				})(),
				(function () {
					const e = document.querySelectorAll("[data-tabs]");
					let t = [];
					if (e.length > 0) {
						const r = i();
						r && r.startsWith("tab-") && (t = r.replace("tab-", "").split("-")),
							e.forEach((e, s) => {
								e.classList.add("_tab-init"),
									e.setAttribute("data-tabs-index", s),
									e.addEventListener("click", o),
									(function (e) {
										let s = e.querySelectorAll("[data-tabs-titles]>*"),
											i = e.querySelectorAll("[data-tabs-body]>*");
										const r = e.dataset.tabsIndex,
											n = t[0] == r;
										if (n) {
											const t = e.querySelector(
												"[data-tabs-titles]>._tab-active",
											);
											t && t.classList.remove("_tab-active");
										}
										i.length &&
											i.forEach((e, i) => {
												s[i].setAttribute("data-tabs-title", ""),
													e.setAttribute("data-tabs-item", ""),
													n && i == t[1] && s[i].classList.add("_tab-active"),
													(e.hidden = !s[i].classList.contains("_tab-active"));
											});
									})(e);
							});
						let n = u(e, "tabs");
						n &&
							n.length &&
							n.forEach((e) => {
								e.matchMedia.addEventListener("change", function () {
									s(e.itemsArray, e.matchMedia);
								}),
									s(e.itemsArray, e.matchMedia);
							});
					}
					function s(e, t) {
						e.forEach((e) => {
							let s = (e = e.item).querySelector("[data-tabs-titles]"),
								i = e.querySelectorAll("[data-tabs-title]"),
								r = e.querySelector("[data-tabs-body]"),
								n = e.querySelectorAll("[data-tabs-item]");
							(i = Array.from(i).filter((t) => t.closest("[data-tabs]") === e)),
								(n = Array.from(n).filter(
									(t) => t.closest("[data-tabs]") === e,
								)),
								n.forEach((n, a) => {
									t.matches
										? (r.append(i[a]),
										  r.append(n),
										  e.classList.add("_tab-spoller"))
										: (s.append(i[a]), e.classList.remove("_tab-spoller"));
								});
						});
					}
					function a(e) {
						let t = e.querySelectorAll("[data-tabs-title]"),
							s = e.querySelectorAll("[data-tabs-item]");
						const i = e.dataset.tabsIndex;
						const a = (function (e) {
							if (e.hasAttribute("data-tabs-animate"))
								return e.dataset.tabsAnimate > 0
									? Number(e.dataset.tabsAnimate)
									: 500;
						})(e);
						if (s.length > 0) {
							const o = e.hasAttribute("data-tabs-hash");
							(s = Array.from(s).filter((t) => t.closest("[data-tabs]") === e)),
								(t = Array.from(t).filter(
									(t) => t.closest("[data-tabs]") === e,
								)),
								s.forEach((e, s) => {
									var l;
									t[s].classList.contains("_tab-active")
										? (a ? n(e, a) : (e.hidden = !1),
										  o &&
												!e.closest(".popup") &&
												((l = (l = `tab-${i}-${s}`)
													? `#${l}`
													: window.location.href.split("#")[0]),
												history.pushState("", "", l)))
										: a
										? r(e, a)
										: (e.hidden = !0);
								});
						}
					}
					function o(e) {
						const t = e.target;
						if (t.closest("[data-tabs-title]")) {
							const s = t.closest("[data-tabs-title]"),
								i = s.closest("[data-tabs]");
							if (
								!s.classList.contains("_tab-active") &&
								!i.querySelector("._slide")
							) {
								let e = i.querySelectorAll("[data-tabs-title]._tab-active");
								e.length &&
									(e = Array.from(e).filter(
										(e) => e.closest("[data-tabs]") === i,
									)),
									e.length && e[0].classList.remove("_tab-active"),
									s.classList.add("_tab-active"),
									a(i);
							}
							e.preventDefault();
						}
					}
				})(),
				window.addEventListener("load", function (e) {
					const t = document.querySelectorAll("[data-showmore]");
					let s, i;
					function a(e) {
						e.forEach((e) => {
							o(e.itemsArray, e.matchMedia);
						});
					}
					function o(e, t) {
						e.forEach((e) => {
							!(function (e, t = !1) {
								let s = (e = t ? e.item : e).querySelectorAll(
										"[data-showmore-content]",
									),
									i = e.querySelectorAll("[data-showmore-button]");
								(s = Array.from(s).filter(
									(t) => t.closest("[data-showmore]") === e,
								)[0]),
									(i = Array.from(i).filter(
										(t) => t.closest("[data-showmore]") === e,
									)[0]);
								const a = l(e, s);
								null !== a &&
									((t.matches || !t) && a < c(s)
										? (r(
												s,
												0,
												e.classList.contains("_showmore-active") ? c(s) : a,
										  ),
										  (i.hidden = !1))
										: (n(s, 0, a), (i.hidden = !0)));
							})(e, t);
						});
					}
					function l(e, t) {
						let s = 0;
						const i = window.innerWidth;
						if (i <= 1023.98) return null;
						const r = e.dataset.showmore ? e.dataset.showmore : "size",
							n = parseFloat(getComputedStyle(t).rowGap) || 0;
						let a;
						if ("items" === r) {
							a = t.dataset.showmoreContent ? t.dataset.showmoreContent : 3;
							const e = t.children;
							for (let t = 1; t < e.length; t++) {
								const i = e[t - 1],
									r = parseFloat(getComputedStyle(i).marginTop) || 0,
									n = parseFloat(getComputedStyle(i).marginBottom) || 0;
								if (((s += i.offsetHeight + r), t == a)) break;
								s += n;
							}
							n && (s += (a - 1) * n);
						} else (a = i <= 1123.98 ? 307 : 383), (s = a);
						return s;
					}
					function c(e) {
						let t,
							s = e.offsetHeight;
						e.style.removeProperty("height"),
							e.closest("[hidden]") &&
								((t = e.closest("[hidden]")), (t.hidden = !1));
						let i = e.offsetHeight;
						return t && (t.hidden = !0), (e.style.height = `${s}px`), i;
					}
					function d(e) {
						const t = e.target,
							c = e.type;
						if ("click" === c) {
							if (t.closest("[data-showmore-button]")) {
								const e = t
										.closest("[data-showmore-button]")
										.closest("[data-showmore]"),
									s = e.querySelector("[data-showmore-content]"),
									i = e.dataset.showmoreButton
										? e.dataset.showmoreButton
										: "500",
									a = l(e, s);
								if (null === a) return;
								s.classList.contains("_slide") ||
									(e.classList.contains("_showmore-active")
										? r(s, i, a)
										: n(s, i, a),
									e.classList.toggle("_showmore-active"));
							}
						} else "resize" === c && (s && s.length && o(s), i && i.length && a(i));
					}
					t.length &&
						((s = Array.from(t).filter(function (e, t, s) {
							return !e.dataset.showmoreMedia;
						})),
						s.length && o(s),
						document.addEventListener("click", d),
						window.addEventListener("resize", d),
						(i = u(t, "showmoreMedia")),
						i &&
							i.length &&
							(i.forEach((e) => {
								e.matchMedia.addEventListener("change", function () {
									o(e.itemsArray, e.matchMedia);
								});
							}),
							a(i)));
				}),
				(function () {
					Xe = !0;
					const e = document.querySelector("header.header");
					if (!e) return;
					const t = e.hasAttribute("data-scroll-show"),
						s = e.dataset.scrollShow ? e.dataset.scrollShow : 500,
						i = e.dataset.scroll ? e.dataset.scroll : 1;
					let r,
						n = 0;
					document.addEventListener("windowScroll", function () {
						const a = window.scrollY;
						clearTimeout(r),
							a >= i
								? (e.classList.add("_header-scroll"),
								  t &&
										(a > n
											? e.classList.remove("_header-show")
											: e.classList.add("_header-show"),
										(r = setTimeout(() => {
											e.classList.add("_header-show");
										}, s))))
								: (e.classList.remove("_header-scroll"),
								  t && e.classList.remove("_header-show")),
							(n = Math.max(a, 0));
					});
				})(),
				(function () {
					function t(t) {
						if ("click" === t.type) {
							const s = t.target;
							if (s.closest("[data-goto]")) {
								const i = s.closest("[data-goto]"),
									r = i.dataset.goto ? i.dataset.goto : "",
									n = !!i.hasAttribute("data-goto-header"),
									a = i.dataset.gotoSpeed ? i.dataset.gotoSpeed : 500,
									o = i.dataset.gotoTop ? parseInt(i.dataset.gotoTop) : 0;
								if (r.includes(".html"))
									return (window.location.href = r), void t.preventDefault();
								let l = r;
								if (r.includes("#")) {
									l = "#" + r.split("#")[1];
								}
								if (
									(document
										.querySelectorAll("[data-goto]._navigator-active")
										.forEach((e) => e.classList.remove("_navigator-active")),
									i.classList.add("_navigator-active"),
									e.fullpage)
								) {
									const t = document
											.querySelector(`${l}`)
											.closest("[data-fp-section]"),
										s = t ? +t.dataset.fpId : null;
									null !== s &&
										(e.fullpage.switchingSection(s),
										document.documentElement.classList.contains("menu-open") &&
											c());
								} else {
									document.querySelector(l)
										? Ye(l, n, a, o)
										: console.warn(
												`   "${l}"    `,
										  );
								}
								if (l) {
									let e = "";
									if (
										((e = l.includes("#")
											? l.split("#")[1]
											: l.startsWith(".") || l.startsWith("#")
											? l.substring(1)
											: l),
										e)
									)
										if (history.pushState) {
											const t =
												window.location.pathname +
												window.location.search +
												"#" +
												e;
											history.pushState(null, null, t);
										} else window.location.hash = e;
								}
								t.preventDefault();
							}
						} else if ("watcherCallback" === t.type && t.detail) {
							const e = t.detail.entry,
								s = e.target;
							if ("navigator" === s.dataset.watch) {
								document.querySelector("[data-goto]._navigator-active");
								let t;
								if (s.id && document.querySelector(`[data-goto="#${s.id}"]`))
									t = document.querySelector(`[data-goto="#${s.id}"]`);
								else if (s.classList.length)
									for (let e = 0; e < s.classList.length; e++) {
										const i = s.classList[e];
										if (document.querySelector(`[data-goto=".${i}"]`)) {
											t = document.querySelector(`[data-goto=".${i}"]`);
											break;
										}
									}
								if (e.isIntersecting) {
									if ((t && t.classList.add("_navigator-active"), t)) {
										const e = t.dataset.goto;
										if (e) {
											let t = "";
											if (
												((t = e.includes("#")
													? e.split("#")[1]
													: e.startsWith(".") || e.startsWith("#")
													? e.substring(1)
													: e),
												t && history.replaceState)
											) {
												const e =
													window.location.pathname +
													window.location.search +
													"#" +
													t;
												history.replaceState(null, null, e);
											}
										}
									}
								} else t && t.classList.remove("_navigator-active");
							}
						}
					}
					if (
						(document.addEventListener("click", t),
						document.addEventListener("watcherCallback", t),
						i())
					) {
						let e;
						document.querySelector(`#${i()}`)
							? (e = `#${i()}`)
							: document.querySelector(`.${i()}`) && (e = `.${i()}`),
					e && Ye(e, !0, 500, 20);
				}
			})();
			(function () {
				function t() {
					const e = document.querySelector(".tabs-tariff__toggle-input");
					if (!e) {
						console.warn("Toggle input not found");
						return;
					}
					const n = e.closest(".tabs-tariff");
					if (!n) {
						console.warn("Tabs-tariff container not found");
						return;
					}
					const s = n.querySelector("[data-tabs-body]");
					if (!s) {
						console.warn("Tabs body container not found");
						return;
					}
					const i = s.querySelectorAll(".tabs-tariff__body");
					if (!i || i.length < 2) {
						console.warn("Not enough tab bodies found:", i ? i.length : 0);
						return;
					}
					const r = n.querySelectorAll("[data-tabs-title]");
					i[1].hidden = !0;
					e.addEventListener("change", function () {
						if (!i || i.length < 2) return;
						if (this.checked) {
							r &&
								r.length >= 2 &&
								(r[0]?.classList.remove("_tab-active"),
								r[1]?.classList.add("_tab-active")),
								(i[0].hidden = !0),
								(i[1].hidden = !1);
						} else {
							r &&
								r.length >= 2 &&
								(r[0]?.classList.add("_tab-active"),
								r[1]?.classList.remove("_tab-active")),
								(i[0].hidden = !1),
								(i[1].hidden = !0);
						}
					});
				}
				"loading" !== document.readyState
					? t()
					: document.addEventListener("DOMContentLoaded", t);
			})();
	})();
})();
